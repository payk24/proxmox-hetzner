#!/usr/bin/env bash
# =============================================================================
# Proxmox VE Auto-Installer for Hetzner Dedicated Servers
# =============================================================================
# This file is auto-generated by build.sh - DO NOT EDIT DIRECTLY
# Edit the source files in scripts/src/ instead
#
# Source modules:
#   00-header.sh     - Colors and initial setup
#   01-helpers.sh    - Helper functions (SSH, download, progress)
#   02-validation.sh - Input validation functions
#   03-hardware.sh   - Hardware detection
#   04-input.sh      - User input collection
#   05-packages.sh   - Package installation and ISO download
#   06-qemu.sh       - QEMU installation functions
#   07-configure.sh  - Post-installation configuration
#   99-main.sh       - Main execution flow
# =============================================================================


# --- 00-header.sh ---
set -e
cd /root

# =============================================================================
# Colors and configuration
# =============================================================================
CLR_RED="\033[1;31m"
CLR_GREEN="\033[1;32m"
CLR_YELLOW="\033[1;33m"
CLR_BLUE="\033[1;34m"
CLR_CYAN="\033[1;36m"
CLR_RESET="\033[m"

# Version
VERSION="1.2.0"

# Log file
LOG_FILE="/root/pve-install-$(date +%Y%m%d-%H%M%S).log"

# Start time for total duration tracking
INSTALL_START_TIME=$(date +%s)

# Default values
NON_INTERACTIVE=false
CONFIG_FILE=""
SAVE_CONFIG=""

# =============================================================================
# Command line argument parsing
# =============================================================================
show_help() {
    cat << EOF
Proxmox VE Automated Installer for Hetzner v${VERSION}

Usage: $0 [OPTIONS]

Options:
  -h, --help              Show this help message
  -c, --config FILE       Load configuration from file
  -s, --save-config FILE  Save configuration to file after input
  -n, --non-interactive   Run without prompts (requires --config)
  -v, --version           Show version

Examples:
  $0                           # Interactive installation
  $0 -s proxmox.conf           # Interactive, save config for later
  $0 -c proxmox.conf           # Load config, prompt for missing values
  $0 -c proxmox.conf -n        # Fully automated installation

EOF
    exit 0
}

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        -v|--version)
            echo "Proxmox Installer v${VERSION}"
            exit 0
            ;;
        -c|--config)
            CONFIG_FILE="$2"
            shift 2
            ;;
        -s|--save-config)
            SAVE_CONFIG="$2"
            shift 2
            ;;
        -n|--non-interactive)
            NON_INTERACTIVE=true
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Validate non-interactive mode requires config
if [[ "$NON_INTERACTIVE" == true && -z "$CONFIG_FILE" ]]; then
    echo -e "${CLR_RED}Error: --non-interactive requires --config FILE${CLR_RESET}"
    exit 1
fi

# =============================================================================
# Config file functions
# =============================================================================
load_config() {
    local file="$1"
    if [[ -f "$file" ]]; then
        echo -e "${CLR_GREEN}✓ Loading configuration from: $file${CLR_RESET}"
        source "$file"
        return 0
    else
        echo -e "${CLR_RED}Config file not found: $file${CLR_RESET}"
        return 1
    fi
}

save_config() {
    local file="$1"
    cat > "$file" << EOF
# Proxmox Installer Configuration
# Generated: $(date)

# Network
INTERFACE_NAME="${INTERFACE_NAME}"

# System
PVE_HOSTNAME="${PVE_HOSTNAME}"
DOMAIN_SUFFIX="${DOMAIN_SUFFIX}"
TIMEZONE="${TIMEZONE}"
EMAIL="${EMAIL}"
PRIVATE_SUBNET="${PRIVATE_SUBNET}"

# Password (consider using environment variable instead)
NEW_ROOT_PASSWORD="${NEW_ROOT_PASSWORD}"

# SSH
SSH_PUBLIC_KEY="${SSH_PUBLIC_KEY}"

# Tailscale
INSTALL_TAILSCALE="${INSTALL_TAILSCALE}"
TAILSCALE_AUTH_KEY="${TAILSCALE_AUTH_KEY}"
TAILSCALE_SSH="${TAILSCALE_SSH}"
TAILSCALE_WEBUI="${TAILSCALE_WEBUI}"

# ZFS RAID mode (single, raid0, raid1)
ZFS_RAID="${ZFS_RAID}"
EOF
    chmod 600 "$file"
    echo -e "${CLR_GREEN}✓ Configuration saved to: $file${CLR_RESET}"
}

# Load config if specified
if [[ -n "$CONFIG_FILE" ]]; then
    load_config "$CONFIG_FILE" || exit 1
fi

# =============================================================================
# Logging setup
# =============================================================================
exec > >(tee -a "$LOG_FILE") 2>&1

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

clear

# =============================================================================
# Install display utilities (boxes for tables, column for alignment)
# =============================================================================
install_display_utils() {
    local need_install=false
    command -v boxes &> /dev/null || need_install=true
    command -v column &> /dev/null || need_install=true

    if $need_install; then
        apt-get update -qq > /dev/null 2>&1
        apt-get install -qq -y boxes bsdmainutils > /dev/null 2>&1
    fi
}
install_display_utils

# =============================================================================
# ASCII Banner
# =============================================================================
echo -e "${CLR_CYAN}"
cat << 'BANNER'
  ____
 |  _ \ _ __ _____  ___ __ ___   _____  __
 | |_) | '__/ _ \ \/ / '_ ` _ \ / _ \ \/ /
 |  __/| | | (_) >  <| | | | | | (_) >  <
 |_|   |_|  \___/_/\_\_| |_| |_|\___/_/\_\

    Hetzner Automated Installer
BANNER
echo -e "${CLR_RESET}"
echo -e "${CLR_YELLOW}Version: ${VERSION}${CLR_RESET}"
echo -e "${CLR_YELLOW}Log file: ${LOG_FILE}${CLR_RESET}"
if [[ -n "$CONFIG_FILE" ]]; then
    echo -e "${CLR_YELLOW}Config: ${CONFIG_FILE}${CLR_RESET}"
fi
if [[ "$NON_INTERACTIVE" == true ]]; then
    echo -e "${CLR_YELLOW}Mode: Non-interactive${CLR_RESET}"
fi
echo ""

# --- 01-helpers.sh ---
# =============================================================================
# Helper functions
# =============================================================================

# Display a boxed section with title using 'boxes'
# Usage: display_box "title" "content"
display_box() {
    local title="$1"
    local content="$2"
    local box_style="${3:-stone}"

    echo -e "${CLR_BLUE}"
    {
        echo "$title"
        echo ""
        echo "$content"
    } | boxes -d "$box_style" -p a1
    echo -e "${CLR_RESET}"
}

# Display system info table using boxes and column
# Takes associative array-like pairs: "label|value|status"
# status: ok=green, warn=yellow, error=red
display_info_table() {
    local title="$1"
    shift
    local items=("$@")

    local content=""
    for item in "${items[@]}"; do
        local label="${item%%|*}"
        local rest="${item#*|}"
        local value="${rest%%|*}"
        local status="${rest#*|}"

        case "$status" in
            ok)    content+="[OK]     $label: $value"$'\n' ;;
            warn)  content+="[WARN]   $label: $value"$'\n' ;;
            error) content+="[ERROR]  $label: $value"$'\n' ;;
            *)     content+="         $label: $value"$'\n' ;;
        esac
    done

    # Remove trailing newline and display
    content="${content%$'\n'}"

    echo ""
    {
        echo "=== $title ==="
        echo ""
        echo "$content"
    } | boxes -d stone -p a1
    echo ""
}

# Colorize the output of boxes (post-process)
colorize_status() {
    local green=$'\033[1;32m'
    local yellow=$'\033[1;33m'
    local red=$'\033[1;31m'
    local reset=$'\033[m'

    sed -e "s/\[OK\]/${green}[OK]${reset}/g" \
        -e "s/\[WARN\]/${yellow}[WARN]${reset}/g" \
        -e "s/\[ERROR\]/${red}[ERROR]${reset}/g"
}

# Download files with retry
download_file() {
    local output_file="$1"
    local url="$2"
    local max_retries=3
    local retry_count=0

    while [ $retry_count -lt $max_retries ]; do
        if wget -q -O "$output_file" "$url"; then
            if [ -s "$output_file" ]; then
                return 0
            else
                echo -e "${CLR_RED}Downloaded file is empty: $output_file${CLR_RESET}"
            fi
        else
            echo -e "${CLR_YELLOW}Download failed (attempt $((retry_count + 1))/$max_retries): $url${CLR_RESET}"
        fi
        retry_count=$((retry_count + 1))
        [ $retry_count -lt $max_retries ] && sleep 2
    done

    echo -e "${CLR_RED}Failed to download $url after $max_retries attempts. Exiting.${CLR_RESET}"
    exit 1
}

# Function to read password with asterisks shown for each character
read_password() {
    local prompt="$1"
    local password=""
    local char=""

    # Output prompt to stderr so it's visible when stdout is captured
    echo -n "$prompt" >&2

    while IFS= read -r -s -n1 char; do
        if [[ -z "$char" ]]; then
            break
        fi
        if [[ "$char" == $'\x7f' || "$char" == $'\x08' ]]; then
            if [[ -n "$password" ]]; then
                password="${password%?}"
                echo -ne "\b \b" >&2
            fi
        else
            password+="$char"
            echo -n "*" >&2
        fi
    done

    # Newline to stderr for display
    echo "" >&2
    # Password to stdout for capture
    echo "$password"
}

# SSH helper functions to reduce duplication
SSH_OPTS="-o StrictHostKeyChecking=no"
SSH_PORT="5555"

remote_exec() {
    sshpass -p "$NEW_ROOT_PASSWORD" ssh -p "$SSH_PORT" $SSH_OPTS root@localhost "$@"
}

remote_exec_script() {
    sshpass -p "$NEW_ROOT_PASSWORD" ssh -p "$SSH_PORT" $SSH_OPTS root@localhost 'bash -s'
}

# Execute remote script with progress indicator (hides output, shows spinner)
remote_exec_with_progress() {
    local message="$1"
    local script="$2"

    echo "$script" | sshpass -p "$NEW_ROOT_PASSWORD" ssh -p "$SSH_PORT" $SSH_OPTS root@localhost 'bash -s' > /dev/null 2>&1 &
    local pid=$!
    show_progress $pid "$message"
    wait $pid
    return $?
}

remote_copy() {
    local src="$1"
    local dst="$2"
    sshpass -p "$NEW_ROOT_PASSWORD" scp -P "$SSH_PORT" $SSH_OPTS "$src" "root@localhost:$dst"
}

# Prompt with validation loop
prompt_validated() {
    local prompt="$1"
    local default="$2"
    local validator="$3"
    local error_msg="$4"
    local result=""

    while true; do
        read -e -p "$prompt" -i "$default" result
        if $validator "$result"; then
            echo "$result"
            return 0
        fi
        echo -e "${CLR_RED}${error_msg}${CLR_RESET}"
    done
}

# Progress indicator with spinner and elapsed time
show_progress() {
    local pid=$1
    local message="${2:-Processing}"
    local spinner='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local start_time=$(date +%s)
    local i=0

    while kill -0 "$pid" 2>/dev/null; do
        local elapsed=$(($(date +%s) - start_time))
        local mins=$((elapsed / 60))
        local secs=$((elapsed % 60))
        printf "\r${CLR_YELLOW}${spinner:i++%${#spinner}:1} %s [%02d:%02d]${CLR_RESET}" "$message" "$mins" "$secs"
        sleep 0.2
    done

    local total=$(($(date +%s) - start_time))
    local mins=$((total / 60))
    local secs=$((total % 60))
    printf "\r${CLR_GREEN}✓ %s completed [%02d:%02d]${CLR_RESET}\n" "$message" "$mins" "$secs"
}

# Wait for condition with progress
wait_with_progress() {
    local message="$1"
    local timeout="$2"
    local check_cmd="$3"
    local interval="${4:-5}"
    local start_time=$(date +%s)
    local spinner='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local i=0

    while true; do
        local elapsed=$(($(date +%s) - start_time))
        local mins=$((elapsed / 60))
        local secs=$((elapsed % 60))

        if eval "$check_cmd" 2>/dev/null; then
            printf "\r${CLR_GREEN}✓ %s [%02d:%02d]${CLR_RESET}\n" "$message" "$mins" "$secs"
            return 0
        fi

        if [ $elapsed -ge $timeout ]; then
            printf "\r${CLR_RED}✗ %s timed out [%02d:%02d]${CLR_RESET}\n" "$message" "$mins" "$secs"
            return 1
        fi

        printf "\r${CLR_YELLOW}${spinner:i++%${#spinner}:1} %s [%02d:%02d]${CLR_RESET}" "$message" "$mins" "$secs"
        sleep "$interval"
    done
}

# --- 02-validation.sh ---
# =============================================================================
# System info collection with progress
# =============================================================================

collect_system_info() {
    local errors=0
    local checks=6
    local current=0
    local spinner='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local i=0

    # Progress update helper
    update_progress() {
        current=$((current + 1))
        local pct=$((current * 100 / checks))
        local filled=$((pct / 5))
        local empty=$((20 - filled))
        printf "\r${CLR_YELLOW}${spinner:i++%${#spinner}:1} Checking system... [${CLR_GREEN}"
        printf '█%.0s' $(seq 1 $filled 2>/dev/null) 2>/dev/null || true
        printf "${CLR_RESET}${CLR_BLUE}"
        printf '░%.0s' $(seq 1 $empty 2>/dev/null) 2>/dev/null || true
        printf "${CLR_RESET}${CLR_YELLOW}] %3d%%${CLR_RESET}" "$pct"
    }

    # Check if running as root
    update_progress
    if [[ $EUID -ne 0 ]]; then
        PREFLIGHT_ROOT="✗ Not root"
        PREFLIGHT_ROOT_CLR="${CLR_RED}"
        errors=$((errors + 1))
    else
        PREFLIGHT_ROOT="✓ Running as root"
        PREFLIGHT_ROOT_CLR="${CLR_GREEN}"
    fi
    sleep 0.1

    # Check internet connectivity
    update_progress
    if ping -c 1 -W 3 1.1.1.1 > /dev/null 2>&1; then
        PREFLIGHT_NET="✓ Available"
        PREFLIGHT_NET_CLR="${CLR_GREEN}"
    else
        PREFLIGHT_NET="✗ No connection"
        PREFLIGHT_NET_CLR="${CLR_RED}"
        errors=$((errors + 1))
    fi

    # Check available disk space (need at least 5GB in /root)
    update_progress
    local free_space_mb=$(df -m /root | awk 'NR==2 {print $4}')
    if [[ $free_space_mb -ge 5000 ]]; then
        PREFLIGHT_DISK="✓ ${free_space_mb} MB"
        PREFLIGHT_DISK_CLR="${CLR_GREEN}"
    else
        PREFLIGHT_DISK="✗ ${free_space_mb} MB (need 5GB+)"
        PREFLIGHT_DISK_CLR="${CLR_RED}"
        errors=$((errors + 1))
    fi
    sleep 0.1

    # Check RAM (need at least 4GB)
    update_progress
    local total_ram_mb=$(free -m | awk '/^Mem:/{print $2}')
    if [[ $total_ram_mb -ge 4000 ]]; then
        PREFLIGHT_RAM="✓ ${total_ram_mb} MB"
        PREFLIGHT_RAM_CLR="${CLR_GREEN}"
    else
        PREFLIGHT_RAM="✗ ${total_ram_mb} MB (need 4GB+)"
        PREFLIGHT_RAM_CLR="${CLR_RED}"
        errors=$((errors + 1))
    fi
    sleep 0.1

    # Check CPU cores
    update_progress
    local cpu_cores=$(nproc)
    if [[ $cpu_cores -ge 2 ]]; then
        PREFLIGHT_CPU="✓ ${cpu_cores} cores"
        PREFLIGHT_CPU_CLR="${CLR_GREEN}"
    else
        PREFLIGHT_CPU="⚠ ${cpu_cores} core(s)"
        PREFLIGHT_CPU_CLR="${CLR_YELLOW}"
    fi
    sleep 0.1

    # Check if KVM is available
    update_progress
    if [[ -e /dev/kvm ]]; then
        PREFLIGHT_KVM="✓ Available"
        PREFLIGHT_KVM_CLR="${CLR_GREEN}"
    else
        PREFLIGHT_KVM="✗ Not available"
        PREFLIGHT_KVM_CLR="${CLR_RED}"
        errors=$((errors + 1))
    fi
    sleep 0.1

    # Clear progress line
    printf "\r\033[K"

    PREFLIGHT_ERRORS=$errors
}

# =============================================================================
# Input validation functions
# =============================================================================

validate_hostname() {
    local hostname="$1"
    # Hostname: alphanumeric and hyphens, 1-63 chars, cannot start/end with hyphen
    if [[ ! "$hostname" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$ ]]; then
        return 1
    fi
    return 0
}

validate_fqdn() {
    local fqdn="$1"
    # FQDN: valid hostname labels separated by dots
    if [[ ! "$fqdn" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$ ]]; then
        return 1
    fi
    return 0
}

validate_email() {
    local email="$1"
    # Basic email validation
    if [[ ! "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        return 1
    fi
    return 0
}

validate_subnet() {
    local subnet="$1"
    # Validate CIDR notation (e.g., 10.0.0.0/24)
    if [[ ! "$subnet" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/([0-9]|[12][0-9]|3[0-2])$ ]]; then
        return 1
    fi
    # Validate each octet is 0-255 using parameter expansion (no read/IFS to avoid terminal issues)
    local ip="${subnet%/*}"
    local octet1 octet2 octet3 octet4 temp
    octet1="${ip%%.*}"
    temp="${ip#*.}"
    octet2="${temp%%.*}"
    temp="${temp#*.}"
    octet3="${temp%%.*}"
    octet4="${temp#*.}"

    if [ "$octet1" -gt 255 ] || [ "$octet2" -gt 255 ] || [ "$octet3" -gt 255 ] || [ "$octet4" -gt 255 ]; then
        return 1
    fi
    return 0
}

validate_timezone() {
    local tz="$1"
    # Check if timezone file exists (preferred validation)
    if [[ -f "/usr/share/zoneinfo/$tz" ]]; then
        return 0
    fi
    # Fallback: In Rescue System, zoneinfo may not be available
    # Validate format (Region/City or Region/Subregion/City)
    if [[ "$tz" =~ ^[A-Za-z_]+/[A-Za-z_]+(/[A-Za-z_]+)?$ ]]; then
        echo -e "${CLR_YELLOW}Note: Cannot verify timezone in Rescue System, format looks valid.${CLR_RESET}"
        return 0
    fi
    return 1
}

# --- 03-hardware.sh ---
# =============================================================================
# System status display
# =============================================================================

show_system_status() {
    # Find all NVMe drives (excluding partitions)
    NVME_DRIVES=($(lsblk -d -n -o NAME,TYPE | grep nvme | grep disk | awk '{print "/dev/"$1}' | sort))

    local nvme_error=0
    if [ ${#NVME_DRIVES[@]} -eq 0 ]; then
        nvme_error=1
    fi

    # Collect drive info
    local -a drive_names=()
    local -a drive_sizes=()
    local -a drive_models=()

    for drive in "${NVME_DRIVES[@]}"; do
        local name=$(basename "$drive")
        local size=$(lsblk -d -n -o SIZE "$drive" | xargs)
        local model=$(lsblk -d -n -o MODEL "$drive" 2>/dev/null | xargs || echo "NVMe")
        drive_names+=("$name")
        drive_sizes+=("$size")
        drive_models+=("$model")
    done

    # Store drive count for RAID mode selection (done in get_system_inputs)
    NVME_COUNT=${#NVME_DRIVES[@]}

    # Set default RAID mode if not already set
    if [ -z "$ZFS_RAID" ]; then
        if [ $NVME_COUNT -lt 2 ]; then
            ZFS_RAID="single"
        else
            ZFS_RAID="raid1"
        fi
    fi

    # Build system info using column for alignment
    local sys_rows=""

    # Root access
    if [[ "$PREFLIGHT_ROOT" == *"Running as root"* ]]; then
        sys_rows+="[OK]|Root Access|Running as root"$'\n'
    else
        sys_rows+="[ERROR]|Root Access|Not root"$'\n'
    fi

    # Internet
    if [[ "$PREFLIGHT_NET" == *"Available"* ]]; then
        sys_rows+="[OK]|Internet|Available"$'\n'
    else
        sys_rows+="[ERROR]|Internet|No connection"$'\n'
    fi

    # Disk space
    if [[ "$PREFLIGHT_DISK" == *"✓"* ]]; then
        local disk_val="${PREFLIGHT_DISK#✓ }"
        sys_rows+="[OK]|Disk Space|${disk_val}"$'\n'
    else
        local disk_val="${PREFLIGHT_DISK#✗ }"
        sys_rows+="[ERROR]|Disk Space|${disk_val}"$'\n'
    fi

    # RAM
    if [[ "$PREFLIGHT_RAM" == *"✓"* ]]; then
        local ram_val="${PREFLIGHT_RAM#✓ }"
        sys_rows+="[OK]|RAM|${ram_val}"$'\n'
    else
        local ram_val="${PREFLIGHT_RAM#✗ }"
        sys_rows+="[ERROR]|RAM|${ram_val}"$'\n'
    fi

    # CPU
    if [[ "$PREFLIGHT_CPU" == *"✓"* ]]; then
        local cpu_val="${PREFLIGHT_CPU#✓ }"
        sys_rows+="[OK]|CPU|${cpu_val}"$'\n'
    elif [[ "$PREFLIGHT_CPU" == *"⚠"* ]]; then
        local cpu_val="${PREFLIGHT_CPU#⚠ }"
        sys_rows+="[WARN]|CPU|${cpu_val}"$'\n'
    else
        local cpu_val="${PREFLIGHT_CPU#✗ }"
        sys_rows+="[ERROR]|CPU|${cpu_val}"$'\n'
    fi

    # KVM
    if [[ "$PREFLIGHT_KVM" == *"Available"* ]]; then
        sys_rows+="[OK]|KVM|Available"
    else
        sys_rows+="[ERROR]|KVM|Not available"
    fi

    # Build storage rows (Mode will be selected interactively in get_system_inputs)
    local storage_rows=""
    if [ $nvme_error -eq 1 ]; then
        storage_rows="[ERROR]|No NVMe drives detected!"
    else
        for i in "${!drive_names[@]}"; do
            storage_rows+="[OK]|${drive_names[$i]}|${drive_sizes[$i]}|${drive_models[$i]:0:25}"
            # Add newline only if not the last item
            if [ $i -lt $((${#drive_names[@]} - 1)) ]; then
                storage_rows+=$'\n'
            fi
        done
    fi

    # Display with boxes and colorize
    {
        echo "SYSTEM INFORMATION"
        echo "$sys_rows" | column -t -s '|'
        echo ""
        echo "--- Storage ---"
        echo "$storage_rows" | column -t -s '|'
    } | boxes -d stone -p a1 | colorize_status
    echo ""

    # Check for errors
    if [[ $PREFLIGHT_ERRORS -gt 0 ]]; then
        echo -e "${CLR_RED}Pre-flight checks failed with $PREFLIGHT_ERRORS error(s). Exiting.${CLR_RESET}"
        exit 1
    fi

    if [ $nvme_error -eq 1 ]; then
        echo -e "${CLR_RED}No NVMe drives detected! Exiting.${CLR_RESET}"
        exit 1
    fi

    echo -e "${CLR_GREEN}All checks passed!${CLR_RESET}"
    echo ""

    # Set drive variables for QEMU
    NVME_DRIVE_1="${NVME_DRIVES[0]}"
    NVME_DRIVE_2="${NVME_DRIVES[1]:-}"
}

# --- 04-input.sh ---
# =============================================================================
# User input functions
# =============================================================================

# Helper to prompt or use existing value
prompt_or_default() {
    local prompt="$1"
    local default="$2"
    local var_name="$3"
    local current_value="${!var_name}"

    if [[ "$NON_INTERACTIVE" == true ]]; then
        if [[ -n "$current_value" ]]; then
            echo "$current_value"
        else
            echo "$default"
        fi
    else
        local result
        read -e -p "$prompt" -i "${current_value:-$default}" result
        echo "$result"
    fi
}

get_system_inputs() {
    # Get default interface name (the one with default route)
    CURRENT_INTERFACE=$(ip route | grep default | awk '{print $5}' | head -n1)
    if [ -z "$CURRENT_INTERFACE" ]; then
        CURRENT_INTERFACE="eth0"
    fi

    # CRITICAL: Get the predictable interface name for bare metal
    # Rescue System often uses eth0, but Proxmox uses predictable naming (enp0s4, eno1, etc.)
    # We must use the predictable name in the config, otherwise network won't work after reboot
    PREDICTABLE_NAME=""

    # Try to get predictable name from udev
    if [ -e "/sys/class/net/${CURRENT_INTERFACE}" ]; then
        # Try ID_NET_NAME_PATH first (most reliable for PCIe devices)
        PREDICTABLE_NAME=$(udevadm info "/sys/class/net/${CURRENT_INTERFACE}" 2>/dev/null | grep "ID_NET_NAME_PATH=" | cut -d'=' -f2)

        # Fallback to ID_NET_NAME_ONBOARD (for onboard NICs)
        if [ -z "$PREDICTABLE_NAME" ]; then
            PREDICTABLE_NAME=$(udevadm info "/sys/class/net/${CURRENT_INTERFACE}" 2>/dev/null | grep "ID_NET_NAME_ONBOARD=" | cut -d'=' -f2)
        fi

        # Fallback to altname from ip link
        if [ -z "$PREDICTABLE_NAME" ]; then
            PREDICTABLE_NAME=$(ip -d link show "$CURRENT_INTERFACE" 2>/dev/null | grep "altname" | awk '{print $2}' | head -1)
        fi
    fi

    # Use predictable name if found, otherwise fall back to current interface name
    if [ -n "$PREDICTABLE_NAME" ]; then
        DEFAULT_INTERFACE="$PREDICTABLE_NAME"
        echo -e "${CLR_GREEN}Detected predictable interface name: ${PREDICTABLE_NAME} (current: ${CURRENT_INTERFACE})${CLR_RESET}"
    else
        DEFAULT_INTERFACE="$CURRENT_INTERFACE"
        echo -e "${CLR_YELLOW}Warning: Could not detect predictable name, using: ${CURRENT_INTERFACE}${CLR_RESET}"
    fi

    # Get all available interfaces and their altnames for display
    AVAILABLE_ALTNAMES=$(ip -d link show | grep -v "lo:" | grep -E '(^[0-9]+:|altname)' | awk '/^[0-9]+:/ {interface=$2; gsub(/:/, "", interface); printf "%s", interface} /altname/ {printf ", %s", $2} END {print ""}' | sed 's/, $//')

    # Set INTERFACE_NAME to default if not already set
    if [ -z "$INTERFACE_NAME" ]; then
        INTERFACE_NAME="$DEFAULT_INTERFACE"
    fi

    # Prompt user for interface name
    if [[ "$NON_INTERACTIVE" != true ]]; then
        echo -e "${CLR_YELLOW}NOTE: Use the predictable name (enp*, eno*) for bare metal, not eth0${CLR_RESET}"
        local iface_prompt="Interface name (options: ${AVAILABLE_ALTNAMES}): "
        read -e -p "$iface_prompt" -i "$INTERFACE_NAME" INTERFACE_NAME
        # Move cursor up one line and overwrite with checkmark
        printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${iface_prompt}${INTERFACE_NAME}\033[K\n"
    fi

    # Get network information from the CURRENT interface (the one active in Rescue)
    # but use INTERFACE_NAME (predictable name) for the Proxmox configuration
    MAIN_IPV4_CIDR=$(ip address show "$CURRENT_INTERFACE" | grep global | grep "inet " | xargs | cut -d" " -f2)
    MAIN_IPV4=$(echo "$MAIN_IPV4_CIDR" | cut -d'/' -f1)
    MAIN_IPV4_GW=$(ip route | grep default | xargs | cut -d" " -f3)
    MAC_ADDRESS=$(ip link show "$CURRENT_INTERFACE" | awk '/ether/ {print $2}')
    IPV6_CIDR=$(ip address show "$CURRENT_INTERFACE" | grep global | grep "inet6 " | xargs | cut -d" " -f2)
    MAIN_IPV6=$(echo "$IPV6_CIDR" | cut -d'/' -f1)

    # Set a default value for FIRST_IPV6_CIDR even if IPV6_CIDR is empty
    if [ -n "$IPV6_CIDR" ]; then
        FIRST_IPV6_CIDR="$(echo "$IPV6_CIDR" | cut -d'/' -f1 | cut -d':' -f1-4):1::1/80"
    else
        FIRST_IPV6_CIDR=""
    fi

    # Get user input for other configuration with validation
    # Note: PVE_HOSTNAME is used instead of HOSTNAME to avoid conflict with bash built-in
    if [[ "$NON_INTERACTIVE" == true ]]; then
        # Use defaults or config values in non-interactive mode
        PVE_HOSTNAME="${PVE_HOSTNAME:-pve}"
        DOMAIN_SUFFIX="${DOMAIN_SUFFIX:-local}"
        TIMEZONE="${TIMEZONE:-Europe/Kyiv}"
        EMAIL="${EMAIL:-admin@example.com}"
        PRIVATE_SUBNET="${PRIVATE_SUBNET:-10.0.0.0/24}"
    else
        local hostname_prompt="Enter your hostname (e.g., pve, proxmox): "
        while true; do
            read -e -p "$hostname_prompt" -i "${PVE_HOSTNAME:-pve}" PVE_HOSTNAME
            if validate_hostname "$PVE_HOSTNAME"; then
                printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${hostname_prompt}${PVE_HOSTNAME}\033[K\n"
                break
            fi
            echo -e "${CLR_RED}Invalid hostname. Use only letters, numbers, and hyphens (1-63 chars, cannot start/end with hyphen).${CLR_RESET}"
        done

        local domain_prompt="Enter domain suffix: "
        read -e -p "$domain_prompt" -i "${DOMAIN_SUFFIX:-local}" DOMAIN_SUFFIX
        printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${domain_prompt}${DOMAIN_SUFFIX}\033[K\n"

        local tz_prompt="Enter your timezone: "
        while true; do
            read -e -p "$tz_prompt" -i "${TIMEZONE:-Europe/Kyiv}" TIMEZONE
            if validate_timezone "$TIMEZONE"; then
                printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${tz_prompt}${TIMEZONE}\033[K\n"
                break
            fi
            echo -e "${CLR_RED}Invalid timezone. Use format like: Europe/London, America/New_York, Asia/Tokyo${CLR_RESET}"
        done

        local email_prompt="Enter your email address: "
        while true; do
            read -e -p "$email_prompt" -i "${EMAIL:-admin@example.com}" EMAIL
            if validate_email "$EMAIL"; then
                printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${email_prompt}${EMAIL}\033[K\n"
                break
            fi
            echo -e "${CLR_RED}Invalid email address format.${CLR_RESET}"
        done

        local subnet_prompt="Enter your private subnet: "
        while true; do
            read -e -p "$subnet_prompt" -i "${PRIVATE_SUBNET:-10.0.0.0/24}" PRIVATE_SUBNET
            if validate_subnet "$PRIVATE_SUBNET"; then
                printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${subnet_prompt}${PRIVATE_SUBNET}\033[K\n"
                break
            fi
            echo -e "${CLR_RED}Invalid subnet. Use CIDR format like: 10.0.0.0/24, 192.168.1.0/24${CLR_RESET}"
        done

        # ZFS RAID mode selection (only if 2+ drives detected)
        if [ "${NVME_COUNT:-0}" -ge 2 ]; then
            # Interactive radio-button style ZFS mode selector
            local options=("raid1" "raid0" "single")
            local labels=("RAID-1 (mirror) - Recommended" "RAID-0 (stripe) - No redundancy" "Single drive - No redundancy")
            local descriptions=("Survives 1 disk failure" "2x space & speed, data loss if any disk fails" "Uses first drive only, ignores other drives")
            local selected=0
            local key=""

            # Save cursor position and hide cursor
            tput sc
            tput civis

            while true; do
                # Move cursor to saved position
                tput rc

                # Draw the selection box
                echo -e "${CLR_CYAN}┌─ ZFS Storage Mode (↑/↓ to select, Enter to confirm) ─┐${CLR_RESET}"
                for i in "${!options[@]}"; do
                    if [ $i -eq $selected ]; then
                        # Selected item - highlighted
                        echo -e "${CLR_CYAN}│${CLR_RESET} ${CLR_GREEN}●${CLR_RESET} ${CLR_WHITE}${labels[$i]}${CLR_RESET}"
                        printf "%-55s${CLR_CYAN}│${CLR_RESET}\n" "     └─ ${descriptions[$i]}"
                    else
                        # Unselected item
                        echo -e "${CLR_CYAN}│${CLR_RESET} ${CLR_BLUE}○${CLR_RESET} ${labels[$i]}"
                        printf "%-55s${CLR_CYAN}│${CLR_RESET}\n" "     └─ ${descriptions[$i]}"
                    fi
                done
                echo -e "${CLR_CYAN}└───────────────────────────────────────────────────────┘${CLR_RESET}"

                # Read a single keypress
                IFS= read -rsn1 key

                # Check for escape sequence (arrow keys)
                if [[ "$key" == $'\x1b' ]]; then
                    read -rsn2 -t 0.1 key
                    case "$key" in
                        '[A') # Up arrow
                            ((selected--))
                            [ $selected -lt 0 ] && selected=$((${#options[@]} - 1))
                            ;;
                        '[B') # Down arrow
                            ((selected++))
                            [ $selected -ge ${#options[@]} ] && selected=0
                            ;;
                    esac
                elif [[ "$key" == "" ]]; then
                    # Enter pressed - confirm selection
                    break
                elif [[ "$key" == "1" ]]; then
                    selected=0; break
                elif [[ "$key" == "2" ]]; then
                    selected=1; break
                elif [[ "$key" == "3" ]]; then
                    selected=2; break
                fi
            done

            # Show cursor again
            tput cnorm

            # Set the selected ZFS RAID mode
            ZFS_RAID="${options[$selected]}"

            # Clear the selection box (8 lines) and show confirmation
            tput rc
            for i in {1..8}; do
                printf "\033[K\n"
            done
            tput rc
            echo -e "${CLR_GREEN}✓${CLR_RESET} ZFS mode: ${labels[$selected]}\033[K"
        fi
    fi

    FQDN="${PVE_HOSTNAME}.${DOMAIN_SUFFIX}"

    # Get the network prefix (first three octets) from PRIVATE_SUBNET
    PRIVATE_CIDR=$(echo "$PRIVATE_SUBNET" | cut -d'/' -f1 | rev | cut -d'.' -f2- | rev)
    PRIVATE_IP="${PRIVATE_CIDR}.1"
    SUBNET_MASK=$(echo "$PRIVATE_SUBNET" | cut -d'/' -f2)
    PRIVATE_IP_CIDR="${PRIVATE_IP}/${SUBNET_MASK}"

    # Password handling
    if [[ "$NON_INTERACTIVE" == true ]]; then
        if [[ -z "$NEW_ROOT_PASSWORD" ]]; then
            echo -e "${CLR_RED}Error: NEW_ROOT_PASSWORD required in non-interactive mode${CLR_RESET}"
            exit 1
        fi
    else
        if [[ -z "$NEW_ROOT_PASSWORD" ]]; then
            local password_prompt="Enter your System New root password: "
            NEW_ROOT_PASSWORD=$(read_password "$password_prompt")
            while [[ -z "$NEW_ROOT_PASSWORD" ]]; do
                echo -e "${CLR_RED}Password cannot be empty!${CLR_RESET}"
                NEW_ROOT_PASSWORD=$(read_password "$password_prompt")
            done
            echo -e "${CLR_GREEN}✓${CLR_RESET} ${password_prompt}********"
        fi
    fi

    # SSH Public Key (required for hardened SSH config)
    if [[ "$NON_INTERACTIVE" == true ]]; then
        # In non-interactive mode, SSH_PUBLIC_KEY must be set in config
        if [[ -z "$SSH_PUBLIC_KEY" ]]; then
            # Try to get from rescue system
            if [[ -f /root/.ssh/authorized_keys ]]; then
                SSH_PUBLIC_KEY=$(grep -E "^ssh-(rsa|ed25519|ecdsa)" /root/.ssh/authorized_keys 2>/dev/null | head -1)
            fi
        fi
        if [[ -z "$SSH_PUBLIC_KEY" ]]; then
            echo -e "${CLR_RED}Error: SSH_PUBLIC_KEY required in non-interactive mode${CLR_RESET}"
            exit 1
        fi
        echo -e "${CLR_GREEN}✓ SSH key configured${CLR_RESET}"
    else
        echo ""
        echo -e "${CLR_YELLOW}============================================${CLR_RESET}"
        echo -e "${CLR_YELLOW}  SSH Public Key Configuration${CLR_RESET}"
        echo -e "${CLR_YELLOW}============================================${CLR_RESET}"
        echo -e "${CLR_RED}Password authentication will be DISABLED!${CLR_RESET}"
        echo ""

        # Try to get SSH key from Rescue System (Hetzner stores it in authorized_keys)
        if [[ -z "$SSH_PUBLIC_KEY" && -f /root/.ssh/authorized_keys ]]; then
            SSH_PUBLIC_KEY=$(grep -E "^ssh-(rsa|ed25519|ecdsa)" /root/.ssh/authorized_keys 2>/dev/null | head -1)
        fi

        if [[ -n "$SSH_PUBLIC_KEY" ]]; then
            echo -e "${CLR_GREEN}Found SSH public key:${CLR_RESET}"
            echo "${SSH_PUBLIC_KEY:0:50}..."
            echo ""
            read -e -p "Use this key? (y/n): " -i "y" USE_RESCUE_KEY
            if [[ ! "$USE_RESCUE_KEY" =~ ^[Yy]$ ]]; then
                SSH_PUBLIC_KEY=""
            fi
        fi

        if [[ -z "$SSH_PUBLIC_KEY" ]]; then
            echo "Paste your SSH public key (usually from ~/.ssh/id_rsa.pub or ~/.ssh/id_ed25519.pub):"
            echo "Example: ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA... user@hostname"
            echo ""
            read -e -p "SSH Public Key: " SSH_PUBLIC_KEY

            while [[ -z "$SSH_PUBLIC_KEY" ]]; do
                echo -e "${CLR_RED}SSH public key is required for secure access!${CLR_RESET}"
                read -e -p "SSH Public Key: " SSH_PUBLIC_KEY
            done

            if [[ ! "$SSH_PUBLIC_KEY" =~ ^ssh-(rsa|ed25519|ecdsa)[[:space:]] ]]; then
                echo -e "${CLR_YELLOW}Warning: SSH key format may be invalid. Continuing anyway...${CLR_RESET}"
            fi
        fi

        echo -e "${CLR_GREEN}✓ SSH key configured${CLR_RESET}"
    fi

    # Tailscale VPN Configuration (Optional)
    if [[ "$NON_INTERACTIVE" == true ]]; then
        # Use config values, default to no if not set
        INSTALL_TAILSCALE="${INSTALL_TAILSCALE:-no}"
        if [[ "$INSTALL_TAILSCALE" == "yes" ]]; then
            TAILSCALE_SSH="${TAILSCALE_SSH:-yes}"
            TAILSCALE_WEBUI="${TAILSCALE_WEBUI:-yes}"
            echo -e "${CLR_GREEN}✓ Tailscale will be installed${CLR_RESET}"
        fi
    else
        echo ""
        echo -e "${CLR_YELLOW}============================================${CLR_RESET}"
        echo -e "${CLR_YELLOW}  Tailscale VPN Configuration (Optional)${CLR_RESET}"
        echo -e "${CLR_YELLOW}============================================${CLR_RESET}"
        echo "Tailscale provides secure remote access to your Proxmox server."
        echo "You can get an auth key from: https://login.tailscale.com/admin/settings/keys"
        echo ""
        read -e -p "Install Tailscale? (y/n): " -i "${INSTALL_TAILSCALE:-y}" INSTALL_TAILSCALE

        if [[ "$INSTALL_TAILSCALE" =~ ^[Yy]$ ]]; then
            INSTALL_TAILSCALE="yes"
            echo ""
            echo "Auth key is optional. If not provided, you'll need to authenticate manually after installation."
            echo "For unattended setup, use a reusable auth key (recommended: with tag and expiry)."
            echo ""
            read -e -p "Tailscale Auth Key (leave empty for manual auth): " -i "${TAILSCALE_AUTH_KEY:-}" TAILSCALE_AUTH_KEY

            if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
                echo -e "${CLR_GREEN}✓ Auth key provided. Tailscale will be configured automatically${CLR_RESET}"
            else
                echo -e "${CLR_YELLOW}No auth key provided. You'll need to run 'tailscale up --ssh' manually after reboot.${CLR_RESET}"
            fi

            TAILSCALE_SSH="yes"
            TAILSCALE_WEBUI="yes"
            echo -e "${CLR_GREEN}Tailscale SSH and Web UI will be enabled.${CLR_RESET}"
            echo -e "${CLR_GREEN}Proxmox Web UI will be accessible at https://HOSTNAME.your-tailnet.ts.net${CLR_RESET}"
        else
            INSTALL_TAILSCALE="no"
            TAILSCALE_AUTH_KEY=""
            TAILSCALE_SSH="no"
            TAILSCALE_WEBUI="no"
            echo -e "${CLR_YELLOW}Tailscale installation skipped.${CLR_RESET}"
        fi
    fi

    # Save config if requested
    if [[ -n "$SAVE_CONFIG" ]]; then
        save_config "$SAVE_CONFIG"
    fi
}

# --- 05-packages.sh ---
# =============================================================================
# Package preparation and ISO download
# =============================================================================

prepare_packages() {
    echo "deb http://download.proxmox.com/debian/pve bookworm pve-no-subscription" > /etc/apt/sources.list.d/pve.list

    # Download Proxmox GPG key
    curl -fsSL -o /etc/apt/trusted.gpg.d/proxmox-release-bookworm.gpg https://enterprise.proxmox.com/debian/proxmox-release-bookworm.gpg &
    show_progress $! "Downloading Proxmox GPG key"
    wait $!
    if [ $? -ne 0 ]; then
        echo -e "${CLR_RED}Failed to download Proxmox GPG key! Exiting.${CLR_RESET}"
        exit 1
    fi

    # Update package lists
    apt clean > /dev/null 2>&1
    apt update > /dev/null 2>&1 &
    show_progress $! "Updating package lists"
    wait $!
    if [ $? -ne 0 ]; then
        echo -e "${CLR_RED}Failed to update package lists! Exiting.${CLR_RESET}"
        exit 1
    fi

    # Install packages
    apt install -yq proxmox-auto-install-assistant xorriso ovmf wget sshpass > /dev/null 2>&1 &
    show_progress $! "Installing packages"
    wait $!
    if [ $? -ne 0 ]; then
        echo -e "${CLR_RED}Failed to install required packages! Exiting.${CLR_RESET}"
        exit 1
    fi
}

# Fetch latest Proxmox VE ISO
get_latest_proxmox_ve_iso() {
    local base_url="https://enterprise.proxmox.com/iso/"
    local latest_iso=$(curl -s "$base_url" | grep -oE 'proxmox-ve_[0-9]+\.[0-9]+-[0-9]+\.iso' | sort -V | tail -n1)

    if [[ -n "$latest_iso" ]]; then
        echo "${base_url}${latest_iso}"
    else
        echo "No Proxmox VE ISO found." >&2
        return 1
    fi
}

download_proxmox_iso() {
    if [[ -f "pve.iso" ]]; then
        echo -e "${CLR_GREEN}✓ Proxmox ISO already exists, skipping download${CLR_RESET}"
        return 0
    fi

    PROXMOX_ISO_URL=$(get_latest_proxmox_ve_iso)
    if [[ -z "$PROXMOX_ISO_URL" ]]; then
        echo -e "${CLR_RED}Failed to retrieve Proxmox ISO URL! Exiting.${CLR_RESET}"
        exit 1
    fi

    ISO_FILENAME=$(basename "$PROXMOX_ISO_URL")
    CHECKSUM_URL="https://enterprise.proxmox.com/iso/SHA256SUMS"

    # Download ISO with progress bar
    wget -q --show-progress -O pve.iso "$PROXMOX_ISO_URL" 2>&1 &
    show_progress $! "Downloading $ISO_FILENAME"
    wait $!
    if [[ $? -ne 0 ]]; then
        echo -e "${CLR_RED}Failed to download Proxmox ISO! Exiting.${CLR_RESET}"
        exit 1
    fi

    if [[ ! -s "pve.iso" ]]; then
        echo -e "${CLR_RED}Downloaded ISO file is empty or corrupted! Exiting.${CLR_RESET}"
        rm -f pve.iso
        exit 1
    fi

    # Verify ISO checksum with progress
    wget -q -O SHA256SUMS "$CHECKSUM_URL" 2>/dev/null &
    show_progress $! "Downloading checksum"
    wait $!

    if [[ -f "SHA256SUMS" ]]; then
        EXPECTED_CHECKSUM=$(grep "$ISO_FILENAME" SHA256SUMS | awk '{print $1}')
        if [[ -n "$EXPECTED_CHECKSUM" ]]; then
            sha256sum pve.iso > /tmp/iso_checksum.txt 2>/dev/null &
            show_progress $! "Verifying ISO checksum"
            wait $!
            ACTUAL_CHECKSUM=$(cat /tmp/iso_checksum.txt | awk '{print $1}')
            rm -f /tmp/iso_checksum.txt

            if [[ "$EXPECTED_CHECKSUM" == "$ACTUAL_CHECKSUM" ]]; then
                echo -e "${CLR_GREEN}✓ ISO checksum verified${CLR_RESET}"
            else
                echo -e "${CLR_RED}ISO checksum verification FAILED!${CLR_RESET}"
                echo -e "${CLR_RED}Expected: $EXPECTED_CHECKSUM${CLR_RESET}"
                echo -e "${CLR_RED}Actual:   $ACTUAL_CHECKSUM${CLR_RESET}"
                rm -f pve.iso SHA256SUMS
                exit 1
            fi
        else
            echo -e "${CLR_YELLOW}⚠ Could not find checksum for $ISO_FILENAME${CLR_RESET}"
        fi
        rm -f SHA256SUMS
    else
        echo -e "${CLR_YELLOW}⚠ Could not download checksum file${CLR_RESET}"
    fi
}

make_answer_toml() {
    echo -e "${CLR_BLUE}Making answer.toml...${CLR_RESET}"

    # Build disk_list based on ZFS_RAID mode (using vda/vdb for QEMU virtio)
    case "$ZFS_RAID" in
        single)
            DISK_LIST='["/dev/vda"]'
            ;;
        raid0|raid1)
            DISK_LIST='["/dev/vda", "/dev/vdb"]'
            ;;
        *)
            # Default to raid1 for 2 drives
            DISK_LIST='["/dev/vda", "/dev/vdb"]'
            ;;
    esac

    cat <<EOF > answer.toml
[global]
    keyboard = "en-us"
    country = "us"
    fqdn = "$FQDN"
    mailto = "$EMAIL"
    timezone = "$TIMEZONE"
    root_password = "$NEW_ROOT_PASSWORD"
    reboot_on_error = false

[network]
    source = "from-dhcp"

[disk-setup]
    filesystem = "zfs"
    zfs.raid = "$ZFS_RAID"
    disk_list = $DISK_LIST

EOF
    echo -e "${CLR_GREEN}✓ answer.toml created (ZFS $ZFS_RAID mode)${CLR_RESET}"
}

make_autoinstall_iso() {
    echo -e "${CLR_BLUE}Making autoinstall.iso...${CLR_RESET}"
    proxmox-auto-install-assistant prepare-iso pve.iso --fetch-from iso --answer-file answer.toml --output pve-autoinstall.iso
    echo -e "${CLR_GREEN}✓ pve-autoinstall.iso created${CLR_RESET}"
}

# --- 06-qemu.sh ---
# =============================================================================
# QEMU installation and boot functions
# =============================================================================

is_uefi_mode() {
    [ -d /sys/firmware/efi ]
}

# Configure QEMU settings (shared between install and boot)
setup_qemu_config() {
    # UEFI configuration
    if is_uefi_mode; then
        UEFI_OPTS="-bios /usr/share/ovmf/OVMF.fd"
        echo -e "${CLR_YELLOW}UEFI mode detected${CLR_RESET}"
    else
        UEFI_OPTS=""
        echo -e "${CLR_YELLOW}Legacy BIOS mode${CLR_RESET}"
    fi

    # CPU and RAM configuration
    local available_cores=$(nproc)
    local available_ram_mb=$(free -m | awk '/^Mem:/{print $2}')

    QEMU_CORES=$((available_cores / 2))
    [ $QEMU_CORES -lt 2 ] && QEMU_CORES=2
    [ $QEMU_CORES -gt $available_cores ] && QEMU_CORES=$available_cores
    [ $QEMU_CORES -gt 16 ] && QEMU_CORES=16

    QEMU_RAM=8192
    [ $available_ram_mb -lt 16384 ] && QEMU_RAM=4096

    # Drive configuration
    DRIVE_ARGS="-drive file=$NVME_DRIVE_1,format=raw,media=disk,if=virtio"
    [ -n "$NVME_DRIVE_2" ] && DRIVE_ARGS="$DRIVE_ARGS -drive file=$NVME_DRIVE_2,format=raw,media=disk,if=virtio"
}

# Install Proxmox via QEMU
install_proxmox() {
    setup_qemu_config

    # Run QEMU in background and show progress
    qemu-system-x86_64 -enable-kvm $UEFI_OPTS \
        -cpu host -smp $QEMU_CORES -m $QEMU_RAM \
        -boot d -cdrom ./pve-autoinstall.iso \
        $DRIVE_ARGS -no-reboot -display none > /dev/null 2>&1 &

    show_progress $! "Installing Proxmox VE (${QEMU_CORES} vCPUs, ${QEMU_RAM}MB RAM)"
}

# Boot installed Proxmox with SSH port forwarding
boot_proxmox_with_port_forwarding() {
    echo -e "${CLR_GREEN}Booting installed Proxmox with SSH port forwarding...${CLR_RESET}"
    setup_qemu_config

    nohup qemu-system-x86_64 -enable-kvm $UEFI_OPTS \
        -cpu host -device e1000,netdev=net0 \
        -netdev user,id=net0,hostfwd=tcp::5555-:22 \
        -smp $QEMU_CORES -m $QEMU_RAM \
        $DRIVE_ARGS -display none \
        > qemu_output.log 2>&1 &

    QEMU_PID=$!

    # Wait for SSH with progress indicator (timeout 5 minutes)
    wait_with_progress "Waiting for Proxmox to boot" 300 "(echo >/dev/tcp/localhost/5555)" 3
}

# --- 07-configure.sh ---
# =============================================================================
# Post-installation configuration
# =============================================================================

make_template_files() {
    echo -e "${CLR_BLUE}Modifying template files...${CLR_RESET}"

    echo -e "${CLR_YELLOW}Downloading template files...${CLR_RESET}"
    mkdir -p ./template_files

    download_file "./template_files/99-proxmox.conf" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/99-proxmox.conf"
    download_file "./template_files/hosts" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/hosts"
    download_file "./template_files/interfaces" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/interfaces"
    download_file "./template_files/debian.sources" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/debian.sources"
    download_file "./template_files/proxmox.sources" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/proxmox.sources"

    # Security hardening templates
    download_file "./template_files/sshd_config" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/sshd_config"

    # Process hosts file
    echo -e "${CLR_YELLOW}Processing hosts file...${CLR_RESET}"
    sed -i "s|{{MAIN_IPV4}}|$MAIN_IPV4|g" ./template_files/hosts
    sed -i "s|{{FQDN}}|$FQDN|g" ./template_files/hosts
    sed -i "s|{{HOSTNAME}}|$PVE_HOSTNAME|g" ./template_files/hosts
    sed -i "s|{{MAIN_IPV6}}|$MAIN_IPV6|g" ./template_files/hosts

    # Process interfaces file
    echo -e "${CLR_YELLOW}Processing interfaces file...${CLR_RESET}"
    sed -i "s|{{INTERFACE_NAME}}|$INTERFACE_NAME|g" ./template_files/interfaces
    sed -i "s|{{MAIN_IPV4}}|$MAIN_IPV4|g" ./template_files/interfaces
    sed -i "s|{{MAIN_IPV4_GW}}|$MAIN_IPV4_GW|g" ./template_files/interfaces
    sed -i "s|{{MAIN_IPV6}}|$MAIN_IPV6|g" ./template_files/interfaces
    sed -i "s|{{PRIVATE_IP_CIDR}}|$PRIVATE_IP_CIDR|g" ./template_files/interfaces
    sed -i "s|{{PRIVATE_SUBNET}}|$PRIVATE_SUBNET|g" ./template_files/interfaces
    sed -i "s|{{FIRST_IPV6_CIDR}}|$FIRST_IPV6_CIDR|g" ./template_files/interfaces

    echo -e "${CLR_GREEN}✓ Template files modified${CLR_RESET}"
}

# Configure the installed Proxmox via SSH
configure_proxmox_via_ssh() {
    echo -e "${CLR_BLUE}Starting post-installation configuration via SSH...${CLR_RESET}"
    make_template_files
    ssh-keygen -f "/root/.ssh/known_hosts" -R "[localhost]:5555" || true

    # Copy template files
    remote_copy "template_files/hosts" "/etc/hosts"
    remote_copy "template_files/interfaces" "/etc/network/interfaces"
    remote_copy "template_files/99-proxmox.conf" "/etc/sysctl.d/99-proxmox.conf"
    remote_copy "template_files/debian.sources" "/etc/apt/sources.list.d/debian.sources"
    remote_copy "template_files/proxmox.sources" "/etc/apt/sources.list.d/proxmox.sources"

    # Basic system configuration
    remote_exec "[ -f /etc/apt/sources.list ] && mv /etc/apt/sources.list /etc/apt/sources.list.bak"
    remote_exec "echo -e 'nameserver 1.1.1.1\nnameserver 1.0.0.1\nnameserver 8.8.8.8\nnameserver 8.8.4.4' > /etc/resolv.conf"
    remote_exec "echo '$PVE_HOSTNAME' > /etc/hostname"
    remote_exec "systemctl disable --now rpcbind rpcbind.socket"

    # Configure ZFS ARC memory limits
    echo -e "${CLR_YELLOW}Configuring ZFS ARC memory limits...${CLR_RESET}"
    remote_exec_script << 'ZFSEOF'
        # Get total RAM in bytes
        TOTAL_RAM_KB=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        TOTAL_RAM_GB=$((TOTAL_RAM_KB / 1024 / 1024))

        # Calculate ARC limits (min: 1GB or 10% of RAM, max: 50% of RAM)
        if [ $TOTAL_RAM_GB -ge 128 ]; then
            ARC_MIN=$((16 * 1024 * 1024 * 1024))  # 16GB min for 128GB+ systems
            ARC_MAX=$((64 * 1024 * 1024 * 1024))  # 64GB max
        elif [ $TOTAL_RAM_GB -ge 64 ]; then
            ARC_MIN=$((8 * 1024 * 1024 * 1024))   # 8GB min
            ARC_MAX=$((32 * 1024 * 1024 * 1024))  # 32GB max
        elif [ $TOTAL_RAM_GB -ge 32 ]; then
            ARC_MIN=$((4 * 1024 * 1024 * 1024))   # 4GB min
            ARC_MAX=$((16 * 1024 * 1024 * 1024))  # 16GB max
        else
            ARC_MIN=$((1 * 1024 * 1024 * 1024))   # 1GB min
            ARC_MAX=$((TOTAL_RAM_KB * 1024 / 2))  # 50% of RAM max
        fi

        # Create ZFS configuration
        mkdir -p /etc/modprobe.d
        echo "options zfs zfs_arc_min=$ARC_MIN" > /etc/modprobe.d/zfs.conf
        echo "options zfs zfs_arc_max=$ARC_MAX" >> /etc/modprobe.d/zfs.conf

        echo "ZFS ARC configured: min=$(($ARC_MIN / 1024 / 1024 / 1024))GB, max=$(($ARC_MAX / 1024 / 1024 / 1024))GB"
ZFSEOF

    # Disable enterprise repositories
    echo -e "${CLR_YELLOW}Disabling enterprise repositories...${CLR_RESET}"
    remote_exec_script << 'REPOEOF'
        # Disable ALL enterprise repositories (PVE, Ceph, Ceph-Squid, etc.)
        # These require a paid subscription and cause 401 errors
        for repo_file in /etc/apt/sources.list.d/*.list /etc/apt/sources.list.d/*.sources; do
            [ -f "$repo_file" ] || continue
            if grep -q "enterprise.proxmox.com" "$repo_file" 2>/dev/null; then
                mv "$repo_file" "${repo_file}.disabled"
                echo "Disabled $(basename "$repo_file")"
            fi
        done

        # Also check and disable any enterprise sources in main sources.list
        if [ -f /etc/apt/sources.list ] && grep -q "enterprise.proxmox.com" /etc/apt/sources.list 2>/dev/null; then
            sed -i 's|^deb.*enterprise.proxmox.com|# &|g' /etc/apt/sources.list
            echo "Commented out enterprise repos in sources.list"
        fi
REPOEOF

    # Update all system packages
    remote_exec_with_progress "Updating system packages" '
        export DEBIAN_FRONTEND=noninteractive
        apt-get update -qq
        apt-get dist-upgrade -yqq
        apt-get autoremove -yqq
        apt-get clean
        pveupgrade 2>/dev/null || true
        pveam update 2>/dev/null || true
    '

    # Install monitoring and system utilities
    remote_exec_with_progress "Installing monitoring utilities" '
        export DEBIAN_FRONTEND=noninteractive
        apt-get install -yqq btop iotop ncdu tmux pigz smartmontools jq bat 2>/dev/null || {
            for pkg in btop iotop ncdu tmux pigz smartmontools jq bat; do
                apt-get install -yqq "$pkg" 2>/dev/null || true
            done
        }
        apt-get install -yqq libguestfs-tools 2>/dev/null || true
    '

    # Configure UTF-8 locales for proper Cyrillic/international character support
    remote_exec_with_progress "Configuring UTF-8 locales" '
        export DEBIAN_FRONTEND=noninteractive
        apt-get install -yqq locales
        sed -i "s/# en_US.UTF-8/en_US.UTF-8/" /etc/locale.gen
        sed -i "s/# ru_RU.UTF-8/ru_RU.UTF-8/" /etc/locale.gen
        locale-gen
        update-locale LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8
    '

    # Configure nf_conntrack
    echo -e "${CLR_YELLOW}Configuring nf_conntrack...${CLR_RESET}"
    remote_exec_script << 'CONNTRACKEOF'
        # Add nf_conntrack module to load at boot
        if ! grep -q "nf_conntrack" /etc/modules 2>/dev/null; then
            echo "nf_conntrack" >> /etc/modules
        fi

        # Configure connection tracking limits
        if ! grep -q "nf_conntrack_max" /etc/sysctl.d/99-proxmox.conf 2>/dev/null; then
            echo "net.netfilter.nf_conntrack_max=1048576" >> /etc/sysctl.d/99-proxmox.conf
            echo "net.netfilter.nf_conntrack_tcp_timeout_established=28800" >> /etc/sysctl.d/99-proxmox.conf
        fi

        echo "nf_conntrack configured"
CONNTRACKEOF

    # Configure CPU governor
    remote_exec_with_progress "Configuring CPU governor" '
        apt-get update -qq && apt-get install -yqq cpufrequtils 2>/dev/null || true
        echo "GOVERNOR=\"performance\"" > /etc/default/cpufrequtils
        if [ -d /sys/devices/system/cpu/cpu0/cpufreq ]; then
            for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
                [ -f "$cpu" ] && echo "performance" > "$cpu" 2>/dev/null || true
            done
        fi
    '

    # Remove Proxmox subscription notice
    echo -e "${CLR_YELLOW}Removing Proxmox subscription notice...${CLR_RESET}"
    remote_exec_script << 'SUBEOF'
        if [ -f /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js ]; then
            sed -Ezi.bak "s/(Ext.Msg.show\(\{\s+title: gettext\('No valid sub)/void\(\{ \/\/\1/g" /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js
            systemctl restart pveproxy.service
            echo "Subscription notice removed"
        else
            echo "proxmoxlib.js not found, skipping"
        fi
SUBEOF

    # Hide Ceph from UI (not needed for single-server setup)
    echo -e "${CLR_YELLOW}Hiding Ceph from UI...${CLR_RESET}"
    remote_exec_script << 'CEPHEOF'
        # Create custom CSS to hide Ceph-related UI elements
        CUSTOM_CSS="/usr/share/pve-manager/css/custom.css"
        cat > "$CUSTOM_CSS" << 'CSS'
/* Hide Ceph menu items - not needed for single server */
#pvelogoV { background-image: url(/pve2/images/logo.png) !important; }
.x-treelist-item-text:has-text("Ceph") { display: none !important; }
tr[data-qtip*="Ceph"] { display: none !important; }
CSS

        # Add custom CSS to index template if not already added
        INDEX_TMPL="/usr/share/pve-manager/index.html.tpl"
        if [ -f "$INDEX_TMPL" ] && ! grep -q "custom.css" "$INDEX_TMPL"; then
            sed -i '/<\/head>/i <link rel="stylesheet" type="text/css" href="/pve2/css/custom.css">' "$INDEX_TMPL"
            echo "Custom CSS added to hide Ceph"
        fi

        # Alternative: patch JavaScript to hide Ceph panel completely
        PVE_MANAGER_JS="/usr/share/pve-manager/js/pvemanagerlib.js"
        if [ -f "$PVE_MANAGER_JS" ]; then
            # Hide Ceph from node tree navigation
            if ! grep -q "// Ceph hidden" "$PVE_MANAGER_JS"; then
                sed -i "s/itemId: 'ceph'/itemId: 'ceph', hidden: true \/\/ Ceph hidden/g" "$PVE_MANAGER_JS" 2>/dev/null || true
            fi
        fi

        systemctl restart pveproxy.service
        echo "Ceph UI elements hidden"
CEPHEOF

    # Install Tailscale if requested
    if [[ "$INSTALL_TAILSCALE" == "yes" ]]; then
        remote_exec_with_progress "Installing Tailscale VPN" '
            curl -fsSL https://pkgs.tailscale.com/stable/debian/bookworm.noarmor.gpg | tee /usr/share/keyrings/tailscale-archive-keyring.gpg >/dev/null
            curl -fsSL https://pkgs.tailscale.com/stable/debian/bookworm.tailscale-keyring.list | tee /etc/apt/sources.list.d/tailscale.list
            apt-get update -qq
            apt-get install -yqq tailscale
            systemctl enable tailscaled
            systemctl start tailscaled
        '

        # Build tailscale up command with selected options
        TAILSCALE_UP_CMD="tailscale up"
        if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            TAILSCALE_UP_CMD="$TAILSCALE_UP_CMD --authkey='$TAILSCALE_AUTH_KEY'"
        fi
        if [[ "$TAILSCALE_SSH" == "yes" ]]; then
            TAILSCALE_UP_CMD="$TAILSCALE_UP_CMD --ssh"
        fi

        # If auth key is provided, authenticate Tailscale
        if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            echo -e "${CLR_YELLOW}Authenticating Tailscale with provided auth key...${CLR_RESET}"
            remote_exec "$TAILSCALE_UP_CMD"

            # Get Tailscale IP and hostname for display
            TAILSCALE_IP=$(remote_exec "tailscale ip -4" 2>/dev/null || echo "pending")
            TAILSCALE_HOSTNAME=$(remote_exec "tailscale status --json | grep -o '\"DNSName\":\"[^\"]*\"' | head -1 | cut -d'\"' -f4 | sed 's/\\.$//' " 2>/dev/null || echo "")
            echo -e "${CLR_GREEN}✓ Tailscale authenticated. IP: ${TAILSCALE_IP}${CLR_RESET}"

            # Configure Tailscale Serve for Proxmox Web UI
            if [[ "$TAILSCALE_WEBUI" == "yes" ]]; then
                echo -e "${CLR_YELLOW}Configuring Tailscale Serve for Proxmox Web UI...${CLR_RESET}"
                remote_exec "tailscale serve --bg --https=443 https://127.0.0.1:8006"
                echo -e "${CLR_GREEN}✓ Proxmox Web UI available via Tailscale Serve${CLR_RESET}"
            fi
        else
            TAILSCALE_IP="not authenticated"
            TAILSCALE_HOSTNAME=""
            echo -e "${CLR_YELLOW}Tailscale installed but not authenticated.${CLR_RESET}"
            echo -e "${CLR_YELLOW}After reboot, run these commands to enable SSH and Web UI:${CLR_RESET}"
            echo -e "${CLR_YELLOW}  tailscale up --ssh${CLR_RESET}"
            echo -e "${CLR_YELLOW}  tailscale serve --bg --https=443 https://127.0.0.1:8006${CLR_RESET}"
        fi
    fi

    # Deploy SSH hardening LAST (after all other operations)
    echo -e "${CLR_YELLOW}Deploying SSH hardening...${CLR_RESET}"

    # Deploy SSH public key FIRST (before disabling password auth!)
    remote_exec "mkdir -p /root/.ssh && chmod 700 /root/.ssh"
    remote_exec "echo '$SSH_PUBLIC_KEY' >> /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys"
    remote_copy "template_files/sshd_config" "/etc/ssh/sshd_config"

    echo -e "${CLR_GREEN}✓ Security hardening configured${CLR_RESET}"

    # Power off the VM
    echo -e "${CLR_YELLOW}Powering off the VM...${CLR_RESET}"
    remote_exec "poweroff" || true

    # Wait for QEMU to exit
    echo -e "${CLR_YELLOW}Waiting for QEMU process to exit...${CLR_RESET}"
    wait $QEMU_PID || true
    echo -e "${CLR_GREEN}✓ QEMU process exited${CLR_RESET}"
}

# --- 99-main.sh ---
# =============================================================================
# Finish and reboot
# =============================================================================

# Calculate and display total installation time
show_total_time() {
    local end_time=$(date +%s)
    local total_seconds=$((end_time - INSTALL_START_TIME))
    local hours=$((total_seconds / 3600))
    local minutes=$(((total_seconds % 3600) / 60))
    local seconds=$((total_seconds % 60))

    if [[ $hours -gt 0 ]]; then
        echo -e "${CLR_GREEN}Total installation time: ${hours}h ${minutes}m ${seconds}s${CLR_RESET}"
    else
        echo -e "${CLR_GREEN}Total installation time: ${minutes}m ${seconds}s${CLR_RESET}"
    fi
}

# Function to reboot into the main OS
reboot_to_main_os() {
    echo -e "${CLR_GREEN}============================================${CLR_RESET}"
    echo -e "${CLR_GREEN}  Installation Complete!${CLR_RESET}"
    echo -e "${CLR_GREEN}============================================${CLR_RESET}"
    show_total_time
    echo ""
    echo -e "${CLR_YELLOW}Security Configuration Summary:${CLR_RESET}"
    echo "  ✓ SSH public key deployed"
    echo "  ✓ Password authentication DISABLED"
    echo "  ✓ CPU governor set to performance"
    echo "  ✓ Kernel parameters optimized for virtualization"
    echo "  ✓ Subscription notice removed"
    echo ""
    echo -e "${CLR_YELLOW}Post-Installation Optimizations:${CLR_RESET}"
    echo "  ✓ Monitoring utilities: btop, iotop, ncdu, tmux, pigz, smartmontools, jq, bat"
    echo "  ✓ VM image tools: libguestfs-tools"
    echo "  ✓ ZFS ARC memory limits configured"
    echo "  ✓ nf_conntrack optimized for high connection counts"
    if [[ "$INSTALL_TAILSCALE" == "yes" ]]; then
        echo "  ✓ Tailscale VPN installed (SSH + Web UI enabled)"
        if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            echo "  ✓ Tailscale authenticated (IP: ${TAILSCALE_IP:-pending})"
        else
            echo "  ⚠ Tailscale needs authentication after reboot:"
            echo "      tailscale up --ssh"
            echo "      tailscale serve --bg --https=443 https://127.0.0.1:8006"
        fi
    fi
    echo ""
    echo -e "${CLR_YELLOW}Access Information:${CLR_RESET}"
    echo "  Web UI:    https://${MAIN_IPV4_CIDR%/*}:8006"
    echo "  SSH:       ssh root@${MAIN_IPV4_CIDR%/*}"
    if [[ "$INSTALL_TAILSCALE" == "yes" && -n "$TAILSCALE_AUTH_KEY" && "$TAILSCALE_IP" != "pending" && "$TAILSCALE_IP" != "not authenticated" ]]; then
        echo "  Tailscale SSH: ssh root@${TAILSCALE_IP}"
        if [[ -n "$TAILSCALE_HOSTNAME" ]]; then
            echo "  Tailscale Web UI: https://${TAILSCALE_HOSTNAME}"
        else
            echo "  Tailscale Web UI: https://${TAILSCALE_IP}:8006"
        fi
    fi
    echo ""

    #ask user to reboot the system
    read -e -p "Do you want to reboot the system? (y/n): " -i "y" REBOOT
    if [[ "$REBOOT" == "y" ]]; then
        echo -e "${CLR_YELLOW}Rebooting the system...${CLR_RESET}"
        reboot
    else
        echo -e "${CLR_YELLOW}Exiting...${CLR_RESET}"
        exit 0
    fi
}

# =============================================================================
# Main execution flow
# =============================================================================

# Collect system info and display status
collect_system_info
show_system_status
get_system_inputs
prepare_packages
download_proxmox_iso
make_answer_toml
make_autoinstall_iso
install_proxmox

# Boot and configure via SSH
boot_proxmox_with_port_forwarding || {
    echo -e "${CLR_RED}Failed to boot Proxmox with port forwarding. Exiting.${CLR_RESET}"
    exit 1
}

# Configure Proxmox via SSH
configure_proxmox_via_ssh

# Reboot to the main OS
reboot_to_main_os
