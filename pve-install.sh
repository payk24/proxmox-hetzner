#!/usr/bin/env bash
# =============================================================================
# Proxmox VE Auto-Installer for Hetzner Dedicated Servers
# =============================================================================
# This file is auto-generated by build.sh - DO NOT EDIT DIRECTLY
# Edit the source files in scripts/src/ instead
#
# Source modules:
#   00-header.sh     - Colors and initial setup
#   01-helpers.sh    - Helper functions (SSH, download, progress)
#   02-validation.sh - Input validation functions
#   03-hardware.sh   - Hardware detection
#   04-input.sh      - User input collection
#   05-packages.sh   - Package installation and ISO download
#   06-qemu.sh       - QEMU installation functions
#   07-configure.sh  - Post-installation configuration
#   99-main.sh       - Main execution flow
# =============================================================================


# --- 00-header.sh ---
set -e
cd /root

# =============================================================================
# Colors and configuration
# =============================================================================
CLR_RED="\033[1;31m"
CLR_GREEN="\033[1;32m"
CLR_YELLOW="\033[1;33m"
CLR_BLUE="\033[1;34m"
CLR_CYAN="\033[1;36m"
CLR_RESET="\033[m"

# Version
VERSION="1.2.0"

# Log file
LOG_FILE="/root/pve-install-$(date +%Y%m%d-%H%M%S).log"

# Start time for total duration tracking
INSTALL_START_TIME=$(date +%s)

# Default values
NON_INTERACTIVE=false
CONFIG_FILE=""
SAVE_CONFIG=""

# Feature flags (defaults)
HIDE_CEPH="${HIDE_CEPH:-yes}"
INSTALL_FAIL2BAN="${INSTALL_FAIL2BAN:-no}"
INSTALL_FIREWALL="${INSTALL_FIREWALL:-no}"
INSTALL_LETSENCRYPT="${INSTALL_LETSENCRYPT:-no}"
INSTALL_UNATTENDED_UPGRADES="${INSTALL_UNATTENDED_UPGRADES:-yes}"
INSTALL_MOTD="${INSTALL_MOTD:-yes}"
ENABLE_PCI_PASSTHROUGH="${ENABLE_PCI_PASSTHROUGH:-no}"
OPTIMIZE_JOURNALD="${OPTIMIZE_JOURNALD:-yes}"

# =============================================================================
# Command line argument parsing
# =============================================================================
show_help() {
    cat << EOF
Proxmox VE Automated Installer for Hetzner v${VERSION}

Usage: $0 [OPTIONS]

Options:
  -h, --help              Show this help message
  -c, --config FILE       Load configuration from file
  -s, --save-config FILE  Save configuration to file after input
  -n, --non-interactive   Run without prompts (requires --config)
  -v, --version           Show version

Examples:
  $0                           # Interactive installation
  $0 -s proxmox.conf           # Interactive, save config for later
  $0 -c proxmox.conf           # Load config, prompt for missing values
  $0 -c proxmox.conf -n        # Fully automated installation

EOF
    exit 0
}

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        -v|--version)
            echo "Proxmox Installer v${VERSION}"
            exit 0
            ;;
        -c|--config)
            CONFIG_FILE="$2"
            shift 2
            ;;
        -s|--save-config)
            SAVE_CONFIG="$2"
            shift 2
            ;;
        -n|--non-interactive)
            NON_INTERACTIVE=true
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Validate non-interactive mode requires config
if [[ "$NON_INTERACTIVE" == true && -z "$CONFIG_FILE" ]]; then
    echo -e "${CLR_RED}Error: --non-interactive requires --config FILE${CLR_RESET}"
    exit 1
fi

# =============================================================================
# Config file functions
# =============================================================================
load_config() {
    local file="$1"
    if [[ -f "$file" ]]; then
        echo -e "${CLR_GREEN}✓ Loading configuration from: $file${CLR_RESET}"
        source "$file"
        return 0
    else
        echo -e "${CLR_RED}Config file not found: $file${CLR_RESET}"
        return 1
    fi
}

save_config() {
    local file="$1"
    cat > "$file" << EOF
# Proxmox Installer Configuration
# Generated: $(date)

# Network
INTERFACE_NAME="${INTERFACE_NAME}"

# System
PVE_HOSTNAME="${PVE_HOSTNAME}"
DOMAIN_SUFFIX="${DOMAIN_SUFFIX}"
TIMEZONE="${TIMEZONE}"
EMAIL="${EMAIL}"
BRIDGE_MODE="${BRIDGE_MODE}"
PRIVATE_SUBNET="${PRIVATE_SUBNET}"

# Password (consider using environment variable instead)
NEW_ROOT_PASSWORD="${NEW_ROOT_PASSWORD}"

# SSH
SSH_PUBLIC_KEY="${SSH_PUBLIC_KEY}"

# Tailscale
INSTALL_TAILSCALE="${INSTALL_TAILSCALE}"
TAILSCALE_AUTH_KEY="${TAILSCALE_AUTH_KEY}"
TAILSCALE_SSH="${TAILSCALE_SSH}"
TAILSCALE_WEBUI="${TAILSCALE_WEBUI}"

# ZFS RAID mode (single, raid0, raid1)
ZFS_RAID="${ZFS_RAID}"

# Optional features
HIDE_CEPH="${HIDE_CEPH}"
INSTALL_FAIL2BAN="${INSTALL_FAIL2BAN}"
INSTALL_FIREWALL="${INSTALL_FIREWALL}"
INSTALL_LETSENCRYPT="${INSTALL_LETSENCRYPT}"
INSTALL_UNATTENDED_UPGRADES="${INSTALL_UNATTENDED_UPGRADES}"
INSTALL_MOTD="${INSTALL_MOTD}"
ENABLE_PCI_PASSTHROUGH="${ENABLE_PCI_PASSTHROUGH}"
OPTIMIZE_JOURNALD="${OPTIMIZE_JOURNALD}"
LETSENCRYPT_DOMAIN="${LETSENCRYPT_DOMAIN}"
EOF
    chmod 600 "$file"
    echo -e "${CLR_GREEN}✓ Configuration saved to: $file${CLR_RESET}"
}

# Load config if specified
if [[ -n "$CONFIG_FILE" ]]; then
    load_config "$CONFIG_FILE" || exit 1
fi

# =============================================================================
# Logging setup
# =============================================================================
exec > >(tee -a "$LOG_FILE") 2>&1

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

clear

# =============================================================================
# Install display utilities (boxes for tables, column for alignment)
# =============================================================================
install_display_utils() {
    local need_install=false
    command -v boxes &> /dev/null || need_install=true
    command -v column &> /dev/null || need_install=true

    if $need_install; then
        apt-get update -qq > /dev/null 2>&1
        apt-get install -qq -y boxes bsdmainutils > /dev/null 2>&1
    fi
}
install_display_utils

# =============================================================================
# ASCII Banner
# =============================================================================
echo -e "${CLR_CYAN}"
cat << 'BANNER'
  ____
 |  _ \ _ __ _____  ___ __ ___   _____  __
 | |_) | '__/ _ \ \/ / '_ ` _ \ / _ \ \/ /
 |  __/| | | (_) >  <| | | | | | (_) >  <
 |_|   |_|  \___/_/\_\_| |_| |_|\___/_/\_\

    Hetzner Automated Installer
BANNER
echo -e "${CLR_RESET}"
echo -e "${CLR_YELLOW}Version: ${VERSION}${CLR_RESET}"
echo -e "${CLR_YELLOW}Log file: ${LOG_FILE}${CLR_RESET}"
if [[ -n "$CONFIG_FILE" ]]; then
    echo -e "${CLR_YELLOW}Config: ${CONFIG_FILE}${CLR_RESET}"
fi
if [[ "$NON_INTERACTIVE" == true ]]; then
    echo -e "${CLR_YELLOW}Mode: Non-interactive${CLR_RESET}"
fi
echo ""

# --- 01-display.sh ---
# =============================================================================
# Display utilities
# =============================================================================

# Display a boxed section with title using 'boxes'
# Usage: display_box "title" "content"
display_box() {
    local title="$1"
    local content="$2"
    local box_style="${3:-stone}"

    echo -e "${CLR_BLUE}"
    {
        echo "$title"
        echo ""
        echo "$content"
    } | boxes -d "$box_style" -p a1
    echo -e "${CLR_RESET}"
}

# Display system info table using boxes and column
# Takes associative array-like pairs: "label|value|status"
# status: ok=green, warn=yellow, error=red
display_info_table() {
    local title="$1"
    shift
    local items=("$@")

    local content=""
    for item in "${items[@]}"; do
        local label="${item%%|*}"
        local rest="${item#*|}"
        local value="${rest%%|*}"
        local status="${rest#*|}"

        case "$status" in
            ok)    content+="[OK]     $label: $value"$'\n' ;;
            warn)  content+="[WARN]   $label: $value"$'\n' ;;
            error) content+="[ERROR]  $label: $value"$'\n' ;;
            *)     content+="         $label: $value"$'\n' ;;
        esac
    done

    # Remove trailing newline and display
    content="${content%$'\n'}"

    echo ""
    {
        echo "=== $title ==="
        echo ""
        echo "$content"
    } | boxes -d stone -p a1
    echo ""
}

# Colorize the output of boxes (post-process)
colorize_status() {
    local green=$'\033[1;32m'
    local yellow=$'\033[1;33m'
    local red=$'\033[1;31m'
    local reset=$'\033[m'

    sed -e "s/\[OK\]/${green}[OK]${reset}/g" \
        -e "s/\[WARN\]/${yellow}[WARN]${reset}/g" \
        -e "s/\[ERROR\]/${red}[ERROR]${reset}/g"
}

# Print success message with checkmark
print_success() {
    echo -e "${CLR_GREEN}✓${CLR_RESET} $1"
}

# Print error message with cross
print_error() {
    echo -e "${CLR_RED}✗${CLR_RESET} $1"
}

# Print warning message
print_warning() {
    echo -e "${CLR_YELLOW}⚠${CLR_RESET} $1"
}

# Print info message
print_info() {
    echo -e "${CLR_CYAN}ℹ${CLR_RESET} $1"
}

# --- 02-utils.sh ---
# =============================================================================
# General utilities
# =============================================================================

# Download files with retry
download_file() {
    local output_file="$1"
    local url="$2"
    local max_retries=3
    local retry_count=0

    while [ $retry_count -lt $max_retries ]; do
        if wget -q -O "$output_file" "$url"; then
            if [ -s "$output_file" ]; then
                return 0
            else
                print_error "Downloaded file is empty: $output_file"
            fi
        else
            print_warning "Download failed (attempt $((retry_count + 1))/$max_retries): $url"
        fi
        retry_count=$((retry_count + 1))
        [ $retry_count -lt $max_retries ] && sleep 2
    done

    print_error "Failed to download $url after $max_retries attempts. Exiting."
    exit 1
}

# Function to read password with asterisks shown for each character
read_password() {
    local prompt="$1"
    local password=""
    local char=""

    # Output prompt to stderr so it's visible when stdout is captured
    echo -n "$prompt" >&2

    while IFS= read -r -s -n1 char; do
        if [[ -z "$char" ]]; then
            break
        fi
        if [[ "$char" == $'\x7f' || "$char" == $'\x08' ]]; then
            if [[ -n "$password" ]]; then
                password="${password%?}"
                echo -ne "\b \b" >&2
            fi
        else
            password+="$char"
            echo -n "*" >&2
        fi
    done

    # Newline to stderr for display
    echo "" >&2
    # Password to stdout for capture
    echo "$password"
}

# Prompt with validation loop
prompt_validated() {
    local prompt="$1"
    local default="$2"
    local validator="$3"
    local error_msg="$4"
    local result=""

    while true; do
        read -e -p "$prompt" -i "$default" result
        if $validator "$result"; then
            echo "$result"
            return 0
        fi
        print_error "$error_msg"
    done
}

# =============================================================================
# Progress indicators
# =============================================================================

# Spinner characters for progress display
SPINNER_CHARS='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'

# Progress indicator with spinner and elapsed time
show_progress() {
    local pid=$1
    local message="${2:-Processing}"
    local start_time=$(date +%s)
    local i=0

    while kill -0 "$pid" 2>/dev/null; do
        local elapsed=$(($(date +%s) - start_time))
        local mins=$((elapsed / 60))
        local secs=$((elapsed % 60))
        printf "\r${CLR_YELLOW}${SPINNER_CHARS:i++%${#SPINNER_CHARS}:1} %s [%02d:%02d]${CLR_RESET}" "$message" "$mins" "$secs"
        sleep 0.2
    done

    local total=$(($(date +%s) - start_time))
    local mins=$((total / 60))
    local secs=$((total % 60))
    printf "\r${CLR_GREEN}✓ %s completed [%02d:%02d]${CLR_RESET}\n" "$message" "$mins" "$secs"
}

# Wait for condition with progress
wait_with_progress() {
    local message="$1"
    local timeout="$2"
    local check_cmd="$3"
    local interval="${4:-5}"
    local start_time=$(date +%s)
    local i=0

    while true; do
        local elapsed=$(($(date +%s) - start_time))
        local mins=$((elapsed / 60))
        local secs=$((elapsed % 60))

        if eval "$check_cmd" 2>/dev/null; then
            printf "\r${CLR_GREEN}✓ %s [%02d:%02d]${CLR_RESET}\n" "$message" "$mins" "$secs"
            return 0
        fi

        if [ $elapsed -ge $timeout ]; then
            printf "\r${CLR_RED}✗ %s timed out [%02d:%02d]${CLR_RESET}\n" "$message" "$mins" "$secs"
            return 1
        fi

        printf "\r${CLR_YELLOW}${SPINNER_CHARS:i++%${#SPINNER_CHARS}:1} %s [%02d:%02d]${CLR_RESET}" "$message" "$mins" "$secs"
        sleep "$interval"
    done
}

# Format time duration
format_duration() {
    local seconds="$1"
    local hours=$((seconds / 3600))
    local minutes=$(((seconds % 3600) / 60))
    local secs=$((seconds % 60))

    if [[ $hours -gt 0 ]]; then
        echo "${hours}h ${minutes}m ${secs}s"
    else
        echo "${minutes}m ${secs}s"
    fi
}

# --- 03-ssh.sh ---
# =============================================================================
# SSH helper functions
# =============================================================================

SSH_OPTS="-o StrictHostKeyChecking=no"
SSH_PORT="5555"

remote_exec() {
    sshpass -p "$NEW_ROOT_PASSWORD" ssh -p "$SSH_PORT" $SSH_OPTS root@localhost "$@"
}

remote_exec_script() {
    sshpass -p "$NEW_ROOT_PASSWORD" ssh -p "$SSH_PORT" $SSH_OPTS root@localhost 'bash -s'
}

# Execute remote script with progress indicator (hides output, shows spinner)
remote_exec_with_progress() {
    local message="$1"
    local script="$2"

    echo "$script" | sshpass -p "$NEW_ROOT_PASSWORD" ssh -p "$SSH_PORT" $SSH_OPTS root@localhost 'bash -s' > /dev/null 2>&1 &
    local pid=$!
    show_progress $pid "$message"
    wait $pid
    return $?
}

remote_copy() {
    local src="$1"
    local dst="$2"
    sshpass -p "$NEW_ROOT_PASSWORD" scp -P "$SSH_PORT" $SSH_OPTS "$src" "root@localhost:$dst"
}

# =============================================================================
# SSH key utilities
# =============================================================================

# Parse SSH public key into components
# Sets: SSH_KEY_TYPE, SSH_KEY_DATA, SSH_KEY_COMMENT, SSH_KEY_SHORT
parse_ssh_key() {
    local key="$1"

    # Reset variables
    SSH_KEY_TYPE=""
    SSH_KEY_DATA=""
    SSH_KEY_COMMENT=""
    SSH_KEY_SHORT=""

    if [[ -z "$key" ]]; then
        return 1
    fi

    # Parse: type base64data [comment]
    SSH_KEY_TYPE=$(echo "$key" | awk '{print $1}')
    SSH_KEY_DATA=$(echo "$key" | awk '{print $2}')
    SSH_KEY_COMMENT=$(echo "$key" | awk '{$1=""; $2=""; print}' | sed 's/^ *//')

    # Create shortened version of key data (first 20 + last 10 chars)
    if [[ ${#SSH_KEY_DATA} -gt 35 ]]; then
        SSH_KEY_SHORT="${SSH_KEY_DATA:0:20}...${SSH_KEY_DATA: -10}"
    else
        SSH_KEY_SHORT="$SSH_KEY_DATA"
    fi

    return 0
}

# Validate SSH public key format
validate_ssh_key() {
    local key="$1"
    [[ "$key" =~ ^ssh-(rsa|ed25519|ecdsa)[[:space:]] ]]
}

# Get SSH key from rescue system authorized_keys
get_rescue_ssh_key() {
    if [[ -f /root/.ssh/authorized_keys ]]; then
        grep -E "^ssh-(rsa|ed25519|ecdsa)" /root/.ssh/authorized_keys 2>/dev/null | head -1
    fi
}

# --- 04-menu.sh ---
# =============================================================================
# Interactive menu selection
# =============================================================================
# Usage: interactive_menu "Title" "header_content" "label1|desc1" "label2|desc2" ...
# Sets: MENU_SELECTED (0-based index of selected option)
# Fixed width: 60 characters for consistent appearance

MENU_BOX_WIDTH=60

interactive_menu() {
    local title="$1"
    local header="$2"
    shift 2
    local items=("$@")

    local -a labels=()
    local -a descriptions=()

    # Parse items into labels and descriptions
    for item in "${items[@]}"; do
        labels+=("${item%%|*}")
        descriptions+=("${item#*|}")
    done

    local selected=0
    local key=""
    local box_lines=0
    local num_options=${#labels[@]}

    # Function to draw the menu box with fixed width
    _draw_menu() {
        local content=""

        # Add header content if provided
        if [[ -n "$header" ]]; then
            content+="$header"$'\n'
            content+=""$'\n'
        fi

        # Add options
        for i in "${!labels[@]}"; do
            if [ $i -eq $selected ]; then
                content+="[*] ${labels[$i]}"$'\n'
                content+="    └─ ${descriptions[$i]}"$'\n'
            else
                content+="[ ] ${labels[$i]}"$'\n'
                content+="    └─ ${descriptions[$i]}"$'\n'
            fi
        done

        # Remove trailing newline
        content="${content%$'\n'}"

        {
            echo "$title"
            echo "$content"
        } | boxes -d stone -p a1 -s $MENU_BOX_WIDTH
    }

    # Hide cursor
    tput civis

    # Calculate box height
    box_lines=$(_draw_menu | wc -l)

    # Draw initial menu
    _draw_menu | sed -e $'s/\\[\\*\\]/\033[1;32m[●]\033[m/g' \
                     -e $'s/\\[ \\]/\033[1;34m[○]\033[m/g'

    while true; do
        # Read a single keypress
        IFS= read -rsn1 key

        # Check for escape sequence (arrow keys)
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 0.1 key || true
            case "$key" in
                '[A') # Up arrow
                    ((selected--)) || true
                    [ $selected -lt 0 ] && selected=$((num_options - 1))
                    ;;
                '[B') # Down arrow
                    ((selected++)) || true
                    [ $selected -ge $num_options ] && selected=0
                    ;;
            esac
        elif [[ "$key" == "" ]]; then
            # Enter pressed - confirm selection
            break
        elif [[ "$key" =~ ^[1-9]$ ]] && [ "$key" -le "$num_options" ]; then
            # Number key pressed
            selected=$((key - 1))
            break
        fi

        # Move cursor up to redraw menu (fixes scroll issue)
        tput cuu $box_lines

        # Clear lines and redraw
        for ((i=0; i<box_lines; i++)); do
            printf "\033[2K\n"
        done
        tput cuu $box_lines

        # Draw the menu with colors
        _draw_menu | sed -e $'s/\\[\\*\\]/\033[1;32m[●]\033[m/g' \
                         -e $'s/\\[ \\]/\033[1;34m[○]\033[m/g'
    done

    # Show cursor again
    tput cnorm

    # Clear the menu box
    tput cuu $box_lines
    for ((i=0; i<box_lines; i++)); do
        printf "\033[2K\n"
    done
    tput cuu $box_lines

    # Set result
    MENU_SELECTED=$selected
}

# Display an input box and prompt for value
# Usage: input_box "title" "content" "prompt" "default" -> result in INPUT_VALUE
input_box() {
    local title="$1"
    local content="$2"
    local prompt="$3"
    local default="$4"

    local box_lines
    box_lines=$({
        echo "$title"
        echo "$content"
    } | boxes -d stone -p a1 -s $MENU_BOX_WIDTH | wc -l)

    {
        echo "$title"
        echo "$content"
    } | boxes -d stone -p a1 -s $MENU_BOX_WIDTH

    read -e -p "$prompt" -i "$default" INPUT_VALUE

    # Clear the input box
    tput cuu $((box_lines + 1))
    for ((i=0; i<box_lines+1; i++)); do
        printf "\033[2K\n"
    done
    tput cuu $((box_lines + 1))
}

# --- 05-validation.sh ---
# =============================================================================
# Input validation functions
# =============================================================================

validate_hostname() {
    local hostname="$1"
    # Hostname: alphanumeric and hyphens, 1-63 chars, cannot start/end with hyphen
    [[ "$hostname" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$ ]]
}

validate_fqdn() {
    local fqdn="$1"
    # FQDN: valid hostname labels separated by dots
    [[ "$fqdn" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$ ]]
}

validate_email() {
    local email="$1"
    # Basic email validation
    [[ "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
}

validate_password() {
    local password="$1"
    # Password must contain only ASCII printable characters (no Cyrillic or other non-ASCII)
    # Allowed: Latin letters, digits, and special characters (ASCII 32-126)
    # Using LC_ALL=C ensures only ASCII characters match [:print:]
    LC_ALL=C bash -c '[[ "$1" =~ ^[[:print:]]+$ ]]' _ "$password"
}

validate_subnet() {
    local subnet="$1"
    # Validate CIDR notation (e.g., 10.0.0.0/24)
    if [[ ! "$subnet" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/([0-9]|[12][0-9]|3[0-2])$ ]]; then
        return 1
    fi
    # Validate each octet is 0-255 using parameter expansion
    local ip="${subnet%/*}"
    local octet1 octet2 octet3 octet4 temp
    octet1="${ip%%.*}"
    temp="${ip#*.}"
    octet2="${temp%%.*}"
    temp="${temp#*.}"
    octet3="${temp%%.*}"
    octet4="${temp#*.}"

    [[ "$octet1" -le 255 && "$octet2" -le 255 && "$octet3" -le 255 && "$octet4" -le 255 ]]
}

validate_timezone() {
    local tz="$1"
    # Check if timezone file exists (preferred validation)
    if [[ -f "/usr/share/zoneinfo/$tz" ]]; then
        return 0
    fi
    # Fallback: In Rescue System, zoneinfo may not be available
    # Validate format (Region/City or Region/Subregion/City)
    if [[ "$tz" =~ ^[A-Za-z_]+/[A-Za-z_]+(/[A-Za-z_]+)?$ ]]; then
        print_warning "Cannot verify timezone in Rescue System, format looks valid."
        return 0
    fi
    return 1
}

# =============================================================================
# Input prompt helpers with validation
# =============================================================================

# Prompt for input with validation, showing success checkmark when valid
# Usage: prompt_with_validation "prompt" "default" "validator" "error_msg" "var_name"
prompt_with_validation() {
    local prompt="$1"
    local default="$2"
    local validator="$3"
    local error_msg="$4"
    local var_name="$5"

    local result
    while true; do
        read -e -p "$prompt" -i "$default" result
        if $validator "$result"; then
            printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${prompt}${result}\033[K\n"
            eval "$var_name=\"\$result\""
            return 0
        fi
        print_error "$error_msg"
    done
}

# Prompt for password with validation
# Usage: prompt_password "prompt" "var_name"
prompt_password() {
    local prompt="$1"
    local var_name="$2"
    local password

    password=$(read_password "$prompt")
    while [[ -z "$password" ]] || ! validate_password "$password"; do
        if [[ -z "$password" ]]; then
            print_error "Password cannot be empty!"
        else
            print_error "Password contains invalid characters (Cyrillic or non-ASCII)."
            print_error "Only Latin letters, digits, and special characters are allowed."
        fi
        password=$(read_password "$prompt")
    done
    printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${prompt}********\033[K\n"
    eval "$var_name=\"\$password\""
}

# --- 06-system-check.sh ---
# =============================================================================
# System checks and hardware detection
# =============================================================================

# Collect system info with progress indicator
collect_system_info() {
    local errors=0
    local checks=6
    local current=0
    local i=0

    # Progress update helper
    update_progress() {
        current=$((current + 1))
        local pct=$((current * 100 / checks))
        local filled=$((pct / 5))
        local empty=$((20 - filled))
        printf "\r${CLR_YELLOW}${SPINNER_CHARS:i++%${#SPINNER_CHARS}:1} Checking system... [${CLR_GREEN}"
        printf '█%.0s' $(seq 1 $filled 2>/dev/null) 2>/dev/null || true
        printf "${CLR_RESET}${CLR_BLUE}"
        printf '░%.0s' $(seq 1 $empty 2>/dev/null) 2>/dev/null || true
        printf "${CLR_RESET}${CLR_YELLOW}] %3d%%${CLR_RESET}" "$pct"
    }

    # Check if running as root
    update_progress
    if [[ $EUID -ne 0 ]]; then
        PREFLIGHT_ROOT="✗ Not root"
        PREFLIGHT_ROOT_STATUS="error"
        errors=$((errors + 1))
    else
        PREFLIGHT_ROOT="Running as root"
        PREFLIGHT_ROOT_STATUS="ok"
    fi
    sleep 0.1

    # Check internet connectivity
    update_progress
    if ping -c 1 -W 3 1.1.1.1 > /dev/null 2>&1; then
        PREFLIGHT_NET="Available"
        PREFLIGHT_NET_STATUS="ok"
    else
        PREFLIGHT_NET="No connection"
        PREFLIGHT_NET_STATUS="error"
        errors=$((errors + 1))
    fi

    # Check available disk space (need at least 5GB in /root)
    update_progress
    local free_space_mb=$(df -m /root | awk 'NR==2 {print $4}')
    if [[ $free_space_mb -ge 5000 ]]; then
        PREFLIGHT_DISK="${free_space_mb} MB"
        PREFLIGHT_DISK_STATUS="ok"
    else
        PREFLIGHT_DISK="${free_space_mb} MB (need 5GB+)"
        PREFLIGHT_DISK_STATUS="error"
        errors=$((errors + 1))
    fi
    sleep 0.1

    # Check RAM (need at least 4GB)
    update_progress
    local total_ram_mb=$(free -m | awk '/^Mem:/{print $2}')
    if [[ $total_ram_mb -ge 4000 ]]; then
        PREFLIGHT_RAM="${total_ram_mb} MB"
        PREFLIGHT_RAM_STATUS="ok"
    else
        PREFLIGHT_RAM="${total_ram_mb} MB (need 4GB+)"
        PREFLIGHT_RAM_STATUS="error"
        errors=$((errors + 1))
    fi
    sleep 0.1

    # Check CPU cores
    update_progress
    local cpu_cores=$(nproc)
    if [[ $cpu_cores -ge 2 ]]; then
        PREFLIGHT_CPU="${cpu_cores} cores"
        PREFLIGHT_CPU_STATUS="ok"
    else
        PREFLIGHT_CPU="${cpu_cores} core(s)"
        PREFLIGHT_CPU_STATUS="warn"
    fi
    sleep 0.1

    # Check if KVM is available
    update_progress
    if [[ -e /dev/kvm ]]; then
        PREFLIGHT_KVM="Available"
        PREFLIGHT_KVM_STATUS="ok"
    else
        PREFLIGHT_KVM="Not available"
        PREFLIGHT_KVM_STATUS="error"
        errors=$((errors + 1))
    fi
    sleep 0.1

    # Clear progress line
    printf "\r\033[K"

    PREFLIGHT_ERRORS=$errors
}

# Detect NVMe drives
detect_nvme_drives() {
    # Find all NVMe drives (excluding partitions)
    NVME_DRIVES=($(lsblk -d -n -o NAME,TYPE | grep nvme | grep disk | awk '{print "/dev/"$1}' | sort))
    NVME_COUNT=${#NVME_DRIVES[@]}

    # Collect drive info
    DRIVE_NAMES=()
    DRIVE_SIZES=()
    DRIVE_MODELS=()

    for drive in "${NVME_DRIVES[@]}"; do
        local name=$(basename "$drive")
        local size=$(lsblk -d -n -o SIZE "$drive" | xargs)
        local model=$(lsblk -d -n -o MODEL "$drive" 2>/dev/null | xargs || echo "NVMe")
        DRIVE_NAMES+=("$name")
        DRIVE_SIZES+=("$size")
        DRIVE_MODELS+=("$model")
    done

    # Set default RAID mode if not already set
    if [[ -z "$ZFS_RAID" ]]; then
        if [[ $NVME_COUNT -lt 2 ]]; then
            ZFS_RAID="single"
        else
            ZFS_RAID="raid1"
        fi
    fi

    # Set drive variables for QEMU
    NVME_DRIVE_1="${NVME_DRIVES[0]:-}"
    NVME_DRIVE_2="${NVME_DRIVES[1]:-}"
}

# Display system status
show_system_status() {
    detect_nvme_drives

    local nvme_error=0
    if [[ $NVME_COUNT -eq 0 ]]; then
        nvme_error=1
    fi

    # Build system info rows
    local sys_rows=""

    # Helper to add row
    add_row() {
        local status="$1"
        local label="$2"
        local value="$3"
        case "$status" in
            ok)    sys_rows+="[OK]|${label}|${value}"$'\n' ;;
            warn)  sys_rows+="[WARN]|${label}|${value}"$'\n' ;;
            error) sys_rows+="[ERROR]|${label}|${value}"$'\n' ;;
        esac
    }

    add_row "$PREFLIGHT_ROOT_STATUS" "Root Access" "$PREFLIGHT_ROOT"
    add_row "$PREFLIGHT_NET_STATUS" "Internet" "$PREFLIGHT_NET"
    add_row "$PREFLIGHT_DISK_STATUS" "Temp Space" "$PREFLIGHT_DISK"
    add_row "$PREFLIGHT_RAM_STATUS" "RAM" "$PREFLIGHT_RAM"
    add_row "$PREFLIGHT_CPU_STATUS" "CPU" "$PREFLIGHT_CPU"
    add_row "$PREFLIGHT_KVM_STATUS" "KVM" "$PREFLIGHT_KVM"

    # Remove trailing newline
    sys_rows="${sys_rows%$'\n'}"

    # Build storage rows
    local storage_rows=""
    if [[ $nvme_error -eq 1 ]]; then
        storage_rows="[ERROR]|No NVMe drives detected!|"
    else
        for i in "${!DRIVE_NAMES[@]}"; do
            storage_rows+="[OK]|${DRIVE_NAMES[$i]}|${DRIVE_SIZES[$i]}  ${DRIVE_MODELS[$i]:0:25}"
            if [[ $i -lt $((${#DRIVE_NAMES[@]} - 1)) ]]; then
                storage_rows+=$'\n'
            fi
        done
    fi

    # Display with boxes and colorize
    # Inner width = MENU_BOX_WIDTH - 4 (borders) - 2 (padding) = 54
    local inner_width=$((MENU_BOX_WIDTH - 6))
    {
        echo "SYSTEM INFORMATION"
        {
            echo "$sys_rows"
            echo "|--- Storage ---|"
            echo "$storage_rows"
        } | column -t -s '|' | while IFS= read -r line; do
            printf "%-${inner_width}s\n" "$line"
        done
    } | boxes -d stone -p a1 -s $MENU_BOX_WIDTH | colorize_status
    echo ""

    # Check for errors
    if [[ $PREFLIGHT_ERRORS -gt 0 ]]; then
        print_error "Pre-flight checks failed with $PREFLIGHT_ERRORS error(s). Exiting."
        exit 1
    fi

    if [[ $nvme_error -eq 1 ]]; then
        print_error "No NVMe drives detected! Exiting."
        exit 1
    fi

    print_success "All checks passed!"
    echo ""
}

# --- 07-input.sh ---
# =============================================================================
# User input functions
# =============================================================================

# Helper to prompt or use existing value
prompt_or_default() {
    local prompt="$1"
    local default="$2"
    local var_name="$3"
    local current_value="${!var_name}"

    if [[ "$NON_INTERACTIVE" == true ]]; then
        if [[ -n "$current_value" ]]; then
            echo "$current_value"
        else
            echo "$default"
        fi
    else
        local result
        read -e -p "$prompt" -i "${current_value:-$default}" result
        echo "$result"
    fi
}

# =============================================================================
# Network interface detection
# =============================================================================

detect_network_interface() {
    # Get default interface name (the one with default route)
    CURRENT_INTERFACE=$(ip route | grep default | awk '{print $5}' | head -n1)
    if [[ -z "$CURRENT_INTERFACE" ]]; then
        CURRENT_INTERFACE="eth0"
    fi

    # CRITICAL: Get the predictable interface name for bare metal
    # Rescue System often uses eth0, but Proxmox uses predictable naming
    PREDICTABLE_NAME=""

    # Try to get predictable name from udev
    if [[ -e "/sys/class/net/${CURRENT_INTERFACE}" ]]; then
        # Try ID_NET_NAME_PATH first (most reliable for PCIe devices)
        PREDICTABLE_NAME=$(udevadm info "/sys/class/net/${CURRENT_INTERFACE}" 2>/dev/null | grep "ID_NET_NAME_PATH=" | cut -d'=' -f2)

        # Fallback to ID_NET_NAME_ONBOARD (for onboard NICs)
        if [[ -z "$PREDICTABLE_NAME" ]]; then
            PREDICTABLE_NAME=$(udevadm info "/sys/class/net/${CURRENT_INTERFACE}" 2>/dev/null | grep "ID_NET_NAME_ONBOARD=" | cut -d'=' -f2)
        fi

        # Fallback to altname from ip link
        if [[ -z "$PREDICTABLE_NAME" ]]; then
            PREDICTABLE_NAME=$(ip -d link show "$CURRENT_INTERFACE" 2>/dev/null | grep "altname" | awk '{print $2}' | head -1)
        fi
    fi

    # Use predictable name if found
    if [[ -n "$PREDICTABLE_NAME" ]]; then
        DEFAULT_INTERFACE="$PREDICTABLE_NAME"
        print_success "Detected predictable interface name: ${PREDICTABLE_NAME} (current: ${CURRENT_INTERFACE})"
    else
        DEFAULT_INTERFACE="$CURRENT_INTERFACE"
        print_warning "Could not detect predictable name, using: ${CURRENT_INTERFACE}"
    fi

    # Get all available interfaces and their altnames for display
    AVAILABLE_ALTNAMES=$(ip -d link show | grep -v "lo:" | grep -E '(^[0-9]+:|altname)' | awk '/^[0-9]+:/ {interface=$2; gsub(/:/, "", interface); printf "%s", interface} /altname/ {printf ", %s", $2} END {print ""}' | sed 's/, $//')

    # Set INTERFACE_NAME to default if not already set
    if [[ -z "$INTERFACE_NAME" ]]; then
        INTERFACE_NAME="$DEFAULT_INTERFACE"
    fi
}

# Get network information from current interface
collect_network_info() {
    MAIN_IPV4_CIDR=$(ip address show "$CURRENT_INTERFACE" | grep global | grep "inet " | xargs | cut -d" " -f2)
    MAIN_IPV4=$(echo "$MAIN_IPV4_CIDR" | cut -d'/' -f1)
    MAIN_IPV4_GW=$(ip route | grep default | xargs | cut -d" " -f3)
    MAC_ADDRESS=$(ip link show "$CURRENT_INTERFACE" | awk '/ether/ {print $2}')
    IPV6_CIDR=$(ip address show "$CURRENT_INTERFACE" | grep global | grep "inet6 " | xargs | cut -d" " -f2)
    MAIN_IPV6=$(echo "$IPV6_CIDR" | cut -d'/' -f1)

    # Set a default value for FIRST_IPV6_CIDR
    if [[ -n "$IPV6_CIDR" ]]; then
        FIRST_IPV6_CIDR="$(echo "$IPV6_CIDR" | cut -d'/' -f1 | cut -d':' -f1-4):1::1/80"
    else
        FIRST_IPV6_CIDR=""
    fi
}

# =============================================================================
# Input collection - Non-interactive mode
# =============================================================================

get_inputs_non_interactive() {
    # Use defaults or config values
    PVE_HOSTNAME="${PVE_HOSTNAME:-pve}"
    DOMAIN_SUFFIX="${DOMAIN_SUFFIX:-local}"
    TIMEZONE="${TIMEZONE:-Europe/Kyiv}"
    EMAIL="${EMAIL:-admin@example.com}"
    BRIDGE_MODE="${BRIDGE_MODE:-internal}"
    PRIVATE_SUBNET="${PRIVATE_SUBNET:-10.0.0.0/24}"

    # Display configuration
    print_success "Network interface: ${INTERFACE_NAME}"
    print_success "Hostname: ${PVE_HOSTNAME}"
    print_success "Domain: ${DOMAIN_SUFFIX}"
    print_success "Timezone: ${TIMEZONE}"
    print_success "Email: ${EMAIL}"
    print_success "Bridge mode: ${BRIDGE_MODE}"

    if [[ "$BRIDGE_MODE" == "internal" || "$BRIDGE_MODE" == "both" ]]; then
        print_success "Private subnet: ${PRIVATE_SUBNET}"
    fi

    # ZFS RAID mode
    if [[ -z "$ZFS_RAID" ]]; then
        if [[ "${NVME_COUNT:-0}" -ge 2 ]]; then
            ZFS_RAID="raid1"
        else
            ZFS_RAID="single"
        fi
    fi
    print_success "ZFS mode: ${ZFS_RAID}"

    # Password required
    if [[ -z "$NEW_ROOT_PASSWORD" ]]; then
        print_error "NEW_ROOT_PASSWORD required in non-interactive mode"
        exit 1
    fi
    if ! validate_password "$NEW_ROOT_PASSWORD"; then
        print_error "Password contains invalid characters (Cyrillic or non-ASCII)."
        exit 1
    fi

    # SSH Public Key
    if [[ -z "$SSH_PUBLIC_KEY" ]]; then
        SSH_PUBLIC_KEY=$(get_rescue_ssh_key)
    fi
    if [[ -z "$SSH_PUBLIC_KEY" ]]; then
        print_error "SSH_PUBLIC_KEY required in non-interactive mode"
        exit 1
    fi
    parse_ssh_key "$SSH_PUBLIC_KEY"
    print_success "SSH key configured (${SSH_KEY_TYPE})"

    # Tailscale
    INSTALL_TAILSCALE="${INSTALL_TAILSCALE:-no}"
    if [[ "$INSTALL_TAILSCALE" == "yes" ]]; then
        TAILSCALE_SSH="${TAILSCALE_SSH:-yes}"
        TAILSCALE_WEBUI="${TAILSCALE_WEBUI:-yes}"
        if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            print_success "Tailscale will be installed (auto-connect)"
        else
            print_success "Tailscale will be installed (manual auth required)"
        fi
        print_success "Tailscale SSH: ${TAILSCALE_SSH}"
        print_success "Tailscale WebUI: ${TAILSCALE_WEBUI}"
    else
        print_success "Tailscale: skipped"
    fi

    # Optional features (use defaults if not set)
    HIDE_CEPH="${HIDE_CEPH:-yes}"
    INSTALL_FAIL2BAN="${INSTALL_FAIL2BAN:-no}"
    INSTALL_FIREWALL="${INSTALL_FIREWALL:-no}"
    INSTALL_LETSENCRYPT="${INSTALL_LETSENCRYPT:-no}"
    INSTALL_UNATTENDED_UPGRADES="${INSTALL_UNATTENDED_UPGRADES:-yes}"
    INSTALL_MOTD="${INSTALL_MOTD:-yes}"
    ENABLE_PCI_PASSTHROUGH="${ENABLE_PCI_PASSTHROUGH:-no}"
    OPTIMIZE_JOURNALD="${OPTIMIZE_JOURNALD:-yes}"

    print_success "Hide Ceph UI: ${HIDE_CEPH}"
    print_success "Fail2ban: ${INSTALL_FAIL2BAN}"
    print_success "Firewall: ${INSTALL_FIREWALL}"
    print_success "Let's Encrypt: ${INSTALL_LETSENCRYPT}"
    print_success "Unattended upgrades: ${INSTALL_UNATTENDED_UPGRADES}"
    print_success "Custom MOTD: ${INSTALL_MOTD}"
    print_success "PCI Passthrough: ${ENABLE_PCI_PASSTHROUGH}"
    print_success "Journald optimization: ${OPTIMIZE_JOURNALD}"
}

# =============================================================================
# Input collection - Interactive mode
# =============================================================================

get_inputs_interactive() {
    # =========================================================================
    # SECTION 1: Text inputs
    # =========================================================================

    # Network interface
    print_warning "Use the predictable name (enp*, eno*) for bare metal, not eth0"
    local iface_prompt="Interface name (options: ${AVAILABLE_ALTNAMES}): "
    read -e -p "$iface_prompt" -i "$INTERFACE_NAME" INTERFACE_NAME
    printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${iface_prompt}${INTERFACE_NAME}\033[K\n"

    # Hostname
    if [[ -n "$PVE_HOSTNAME" ]]; then
        print_success "Hostname: ${PVE_HOSTNAME} (from env)"
    else
        prompt_with_validation \
            "Enter your hostname (e.g., pve, proxmox): " \
            "pve" \
            "validate_hostname" \
            "Invalid hostname. Use only letters, numbers, and hyphens (1-63 chars)." \
            "PVE_HOSTNAME"
    fi

    # Domain
    if [[ -n "$DOMAIN_SUFFIX" ]]; then
        print_success "Domain: ${DOMAIN_SUFFIX} (from env)"
    else
        local domain_prompt="Enter domain suffix: "
        read -e -p "$domain_prompt" -i "local" DOMAIN_SUFFIX
        printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${domain_prompt}${DOMAIN_SUFFIX}\033[K\n"
    fi

    # Email
    if [[ -n "$EMAIL" ]]; then
        print_success "Email: ${EMAIL} (from env)"
    else
        prompt_with_validation \
            "Enter your email address: " \
            "admin@example.com" \
            "validate_email" \
            "Invalid email address format." \
            "EMAIL"
    fi

    # Password
    if [[ -n "$NEW_ROOT_PASSWORD" ]]; then
        if ! validate_password "$NEW_ROOT_PASSWORD"; then
            print_error "Password contains invalid characters (Cyrillic or non-ASCII)."
            print_error "Only Latin letters, digits, and special characters are allowed."
            exit 1
        fi
        print_success "Password: ******** (from env)"
    else
        prompt_password "Enter your System New root password: " "NEW_ROOT_PASSWORD"
    fi

    # =========================================================================
    # SECTION 2: Interactive menus
    # =========================================================================

    # --- Timezone ---
    if [[ -n "$TIMEZONE" ]]; then
        print_success "Timezone: ${TIMEZONE} (from env)"
    else
        local tz_options=("Europe/Kyiv" "Europe/London" "Europe/Berlin" "America/New_York" "America/Los_Angeles" "Asia/Tokyo" "UTC" "custom")

        interactive_menu \
            "Timezone (↑/↓ select, Enter confirm)" \
            "" \
            "Europe/Kyiv|Ukraine" \
            "Europe/London|United Kingdom (GMT/BST)" \
            "Europe/Berlin|Germany, Central Europe (CET/CEST)" \
            "America/New_York|US Eastern Time (EST/EDT)" \
            "America/Los_Angeles|US Pacific Time (PST/PDT)" \
            "Asia/Tokyo|Japan Standard Time (JST)" \
            "UTC|Coordinated Universal Time" \
            "Custom|Enter timezone manually"

        if [[ $MENU_SELECTED -eq 7 ]]; then
            prompt_with_validation \
                "Enter your timezone: " \
                "Europe/Kyiv" \
                "validate_timezone" \
                "Invalid timezone. Use format like: Europe/London, America/New_York" \
                "TIMEZONE"
        else
            TIMEZONE="${tz_options[$MENU_SELECTED]}"
            print_success "Timezone: ${TIMEZONE}"
        fi
    fi

    # --- Bridge mode ---
    if [[ -n "$BRIDGE_MODE" ]]; then
        print_success "Bridge mode: ${BRIDGE_MODE} (from env)"
    else
        local bridge_options=("internal" "external" "both")
        local bridge_header="Configure network bridges for VMs and containers"$'\n'
        bridge_header+="vmbr0 = external (bridged to physical NIC)"$'\n'
        bridge_header+="vmbr1 = internal (NAT with private subnet)"

        interactive_menu \
            "Network Bridge Mode (↑/↓ select, Enter confirm)" \
            "$bridge_header" \
            "Internal only (NAT)|VMs use private IPs with NAT to internet" \
            "External only (Bridged)|VMs get IPs from your router/DHCP" \
            "Both bridges|Internal NAT + External bridged network"

        BRIDGE_MODE="${bridge_options[$MENU_SELECTED]}"
        case "$BRIDGE_MODE" in
            internal) print_success "Bridge mode: Internal NAT only (vmbr0)" ;;
            external) print_success "Bridge mode: External bridged only (vmbr0)" ;;
            both)     print_success "Bridge mode: Both (vmbr0=external, vmbr1=internal)" ;;
        esac
    fi

    # --- Private subnet ---
    if [[ "$BRIDGE_MODE" == "internal" || "$BRIDGE_MODE" == "both" ]]; then
        if [[ -n "$PRIVATE_SUBNET" ]]; then
            print_success "Private subnet: ${PRIVATE_SUBNET} (from env)"
        else
            local subnet_options=("10.0.0.0/24" "192.168.1.0/24" "172.16.0.0/24" "custom")

            interactive_menu \
                "Private Subnet (↑/↓ select, Enter confirm)" \
                "Internal network for VMs and containers" \
                "10.0.0.0/24|Class A private (recommended)" \
                "192.168.1.0/24|Class C private (common home network)" \
                "172.16.0.0/24|Class B private" \
                "Custom|Enter subnet manually"

            if [[ $MENU_SELECTED -eq 3 ]]; then
                prompt_with_validation \
                    "Enter your private subnet: " \
                    "10.0.0.0/24" \
                    "validate_subnet" \
                    "Invalid subnet. Use CIDR format like: 10.0.0.0/24" \
                    "PRIVATE_SUBNET"
            else
                PRIVATE_SUBNET="${subnet_options[$MENU_SELECTED]}"
                print_success "Private subnet: ${PRIVATE_SUBNET}"
            fi
        fi
    fi

    # --- ZFS RAID mode ---
    if [[ "${NVME_COUNT:-0}" -ge 2 ]]; then
        if [[ -n "$ZFS_RAID" ]]; then
            print_success "ZFS mode: ${ZFS_RAID} (from env)"
        else
            local zfs_options=("raid1" "raid0" "single")
            local zfs_labels=("RAID-1 (mirror) - Recommended" "RAID-0 (stripe) - No redundancy" "Single drive - No redundancy")

            interactive_menu \
                "ZFS Storage Mode (↑/↓ select, Enter confirm)" \
                "" \
                "${zfs_labels[0]}|Survives 1 disk failure" \
                "${zfs_labels[1]}|2x space & speed, data loss if any disk fails" \
                "${zfs_labels[2]}|Uses first drive only, ignores other drives"

            ZFS_RAID="${zfs_options[$MENU_SELECTED]}"
            print_success "ZFS mode: ${zfs_labels[$MENU_SELECTED]}"
        fi
    fi

    # --- SSH Public Key ---
    if [[ -n "$SSH_PUBLIC_KEY" ]]; then
        parse_ssh_key "$SSH_PUBLIC_KEY"
        print_success "SSH key: ${SSH_KEY_TYPE} (from env)"
    else
        local DETECTED_SSH_KEY=$(get_rescue_ssh_key)

        if [[ -n "$DETECTED_SSH_KEY" ]]; then
            parse_ssh_key "$DETECTED_SSH_KEY"

            local ssh_header="! Password authentication will be DISABLED"$'\n'
            ssh_header+="Detected key from Rescue System:"$'\n'
            ssh_header+="  Type:    ${SSH_KEY_TYPE}"$'\n'
            ssh_header+="  Key:     ${SSH_KEY_SHORT}"
            if [[ -n "$SSH_KEY_COMMENT" ]]; then
                ssh_header+=$'\n'"  Comment: ${SSH_KEY_COMMENT}"
            fi

            interactive_menu \
                "SSH Public Key (↑/↓ select, Enter confirm)" \
                "$ssh_header" \
                "Use detected key|Recommended - already configured in Hetzner" \
                "Enter different key|Paste your own SSH public key"

            if [[ $MENU_SELECTED -eq 0 ]]; then
                SSH_PUBLIC_KEY="$DETECTED_SSH_KEY"
                print_success "SSH key configured (${SSH_KEY_TYPE})"
            else
                SSH_PUBLIC_KEY=""
            fi
        fi

        # Manual entry if no key yet
        if [[ -z "$SSH_PUBLIC_KEY" ]]; then
            local ssh_content="! Password authentication will be DISABLED"$'\n'
            if [[ -z "$DETECTED_SSH_KEY" ]]; then
                ssh_content+=$'\n'"No SSH key detected in Rescue System."
            fi
            ssh_content+=$'\n'$'\n'"Paste your SSH public key below:"$'\n'
            ssh_content+="(Usually from ~/.ssh/id_ed25519.pub or ~/.ssh/id_rsa.pub)"

            input_box "SSH Public Key Configuration" "$ssh_content" "SSH Public Key: " ""

            while [[ -z "$INPUT_VALUE" ]] || ! validate_ssh_key "$INPUT_VALUE"; do
                if [[ -z "$INPUT_VALUE" ]]; then
                    print_error "SSH public key is required for secure access!"
                else
                    print_warning "SSH key format may be invalid. Continue anyway? (y/n): "
                    read -rsn1 confirm
                    echo ""
                    if [[ "$confirm" =~ ^[Yy]$ ]]; then
                        break
                    fi
                fi
                input_box "SSH Public Key Configuration" "$ssh_content" "SSH Public Key: " ""
            done

            SSH_PUBLIC_KEY="$INPUT_VALUE"
            parse_ssh_key "$SSH_PUBLIC_KEY"
            print_success "SSH key configured (${SSH_KEY_TYPE})"
        fi
    fi

    # --- Tailscale ---
    if [[ -n "$INSTALL_TAILSCALE" ]]; then
        if [[ "$INSTALL_TAILSCALE" == "yes" ]]; then
            TAILSCALE_SSH="${TAILSCALE_SSH:-yes}"
            TAILSCALE_WEBUI="${TAILSCALE_WEBUI:-yes}"
            if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
                print_success "Tailscale: yes (auto-connect, from env)"
            else
                print_success "Tailscale: yes (manual auth, from env)"
            fi
        else
            TAILSCALE_AUTH_KEY=""
            TAILSCALE_SSH="no"
            TAILSCALE_WEBUI="no"
            print_success "Tailscale: skipped (from env)"
        fi
    else
        local ts_header="Tailscale provides secure remote access to your server."$'\n'
        ts_header+="Auth key: https://login.tailscale.com/admin/settings/keys"

        interactive_menu \
            "Tailscale VPN - Optional (↑/↓ select, Enter confirm)" \
            "$ts_header" \
            "Install Tailscale|Recommended for secure remote access" \
            "Skip installation|Install Tailscale later if needed"

        if [[ $MENU_SELECTED -eq 0 ]]; then
            INSTALL_TAILSCALE="yes"
            TAILSCALE_SSH="yes"
            TAILSCALE_WEBUI="yes"

            if [[ -z "$TAILSCALE_AUTH_KEY" ]]; then
                local auth_content="Auth key enables automatic configuration."$'\n'
                auth_content+="Leave empty for manual auth after reboot."$'\n'
                auth_content+=$'\n'
                auth_content+="For unattended setup, use a reusable auth key"$'\n'
                auth_content+="with tags and expiry for better security."

                input_box "Tailscale Auth Key (optional)" "$auth_content" "Auth Key: " ""
                TAILSCALE_AUTH_KEY="$INPUT_VALUE"
            fi

            if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
                print_success "Tailscale will be installed (auto-connect)"
            else
                print_success "Tailscale will be installed (manual auth required)"
            fi
        else
            INSTALL_TAILSCALE="no"
            TAILSCALE_AUTH_KEY=""
            TAILSCALE_SSH="no"
            TAILSCALE_WEBUI="no"
            print_success "Tailscale installation skipped"
        fi
    fi

    # --- Advanced Options ---
    # Check if any advanced option is already set from env
    local advanced_from_env=false
    if [[ -n "$HIDE_CEPH" || -n "$INSTALL_FAIL2BAN" || -n "$INSTALL_FIREWALL" || \
          -n "$INSTALL_LETSENCRYPT" || -n "$INSTALL_UNATTENDED_UPGRADES" || \
          -n "$INSTALL_MOTD" || -n "$ENABLE_PCI_PASSTHROUGH" || -n "$OPTIMIZE_JOURNALD" ]]; then
        advanced_from_env=true
    fi

    if [[ "$advanced_from_env" == true ]]; then
        # Use values from environment/config, apply defaults
        HIDE_CEPH="${HIDE_CEPH:-yes}"
        INSTALL_FAIL2BAN="${INSTALL_FAIL2BAN:-no}"
        INSTALL_FIREWALL="${INSTALL_FIREWALL:-no}"
        INSTALL_LETSENCRYPT="${INSTALL_LETSENCRYPT:-no}"
        INSTALL_UNATTENDED_UPGRADES="${INSTALL_UNATTENDED_UPGRADES:-yes}"
        INSTALL_MOTD="${INSTALL_MOTD:-yes}"
        ENABLE_PCI_PASSTHROUGH="${ENABLE_PCI_PASSTHROUGH:-no}"
        OPTIMIZE_JOURNALD="${OPTIMIZE_JOURNALD:-yes}"

        print_success "Advanced options loaded from config/env"
        [[ "$HIDE_CEPH" == "yes" ]] && print_success "  Hide Ceph UI: yes"
        [[ "$INSTALL_FAIL2BAN" == "yes" ]] && print_success "  Fail2ban: yes"
        [[ "$INSTALL_FIREWALL" == "yes" ]] && print_success "  Firewall: yes"
        [[ "$INSTALL_LETSENCRYPT" == "yes" ]] && print_success "  Let's Encrypt: yes"
        [[ "$INSTALL_UNATTENDED_UPGRADES" == "yes" ]] && print_success "  Unattended upgrades: yes"
        [[ "$INSTALL_MOTD" == "yes" ]] && print_success "  Custom MOTD: yes"
        [[ "$ENABLE_PCI_PASSTHROUGH" == "yes" ]] && print_success "  PCI Passthrough: yes"
        [[ "$OPTIMIZE_JOURNALD" == "yes" ]] && print_success "  Journald optimization: yes"
    else
        # Set defaults first
        HIDE_CEPH="yes"
        INSTALL_FAIL2BAN="no"
        INSTALL_FIREWALL="no"
        INSTALL_LETSENCRYPT="no"
        INSTALL_UNATTENDED_UPGRADES="yes"
        INSTALL_MOTD="yes"
        ENABLE_PCI_PASSTHROUGH="no"
        OPTIMIZE_JOURNALD="yes"

        local adv_header="Configure additional features for your Proxmox installation."$'\n'
        adv_header+="Defaults are optimized for most use cases."

        interactive_menu \
            "Advanced Options (↑/↓ select, Enter confirm)" \
            "$adv_header" \
            "Use defaults|Recommended settings for most users" \
            "Customize|Configure each option individually"

        if [[ $MENU_SELECTED -eq 1 ]]; then
            # --- Hide Ceph UI ---
            interactive_menu \
                "Hide Ceph UI (↑/↓ select, Enter confirm)" \
                "Ceph is distributed storage, not needed for single-server" \
                "Yes - Hide Ceph|Clean UI without Ceph menu items" \
                "No - Show Ceph|Keep Ceph menu visible"
            [[ $MENU_SELECTED -eq 0 ]] && HIDE_CEPH="yes" || HIDE_CEPH="no"
            print_success "Hide Ceph UI: ${HIDE_CEPH}"

            # --- Fail2ban ---
            interactive_menu \
                "Fail2ban - Brute-force Protection (↑/↓ select, Enter confirm)" \
                "Blocks IPs after failed login attempts" \
                "No - Skip|Install manually later if needed" \
                "Yes - Install|Protect SSH and PVE Web from attacks"
            [[ $MENU_SELECTED -eq 1 ]] && INSTALL_FAIL2BAN="yes" || INSTALL_FAIL2BAN="no"
            print_success "Fail2ban: ${INSTALL_FAIL2BAN}"

            # --- Firewall ---
            interactive_menu \
                "Basic Firewall (↑/↓ select, Enter confirm)" \
                "iptables rules: allow SSH(22), PVE Web(8006), block rest" \
                "No - Skip|No firewall rules (use PVE firewall instead)" \
                "Yes - Enable|Basic host-level firewall protection"
            [[ $MENU_SELECTED -eq 1 ]] && INSTALL_FIREWALL="yes" || INSTALL_FIREWALL="no"
            print_success "Firewall: ${INSTALL_FIREWALL}"

            # --- Let's Encrypt ---
            interactive_menu \
                "Let's Encrypt SSL Certificate (↑/↓ select, Enter confirm)" \
                "Free HTTPS certificate for Proxmox Web UI" \
                "No - Skip|Use self-signed certificate" \
                "Yes - Install|Requires valid domain pointing to this server"
            if [[ $MENU_SELECTED -eq 1 ]]; then
                INSTALL_LETSENCRYPT="yes"
                input_box "Let's Encrypt Domain" "Enter the domain for SSL certificate:" "Domain: " "${FQDN:-}"
                LETSENCRYPT_DOMAIN="$INPUT_VALUE"
                print_success "Let's Encrypt: yes (${LETSENCRYPT_DOMAIN})"
            else
                INSTALL_LETSENCRYPT="no"
                print_success "Let's Encrypt: no"
            fi

            # --- Unattended Upgrades ---
            interactive_menu \
                "Unattended Security Upgrades (↑/↓ select, Enter confirm)" \
                "Automatically install security updates" \
                "Yes - Enable|Recommended for security" \
                "No - Disable|Manual updates only"
            [[ $MENU_SELECTED -eq 0 ]] && INSTALL_UNATTENDED_UPGRADES="yes" || INSTALL_UNATTENDED_UPGRADES="no"
            print_success "Unattended upgrades: ${INSTALL_UNATTENDED_UPGRADES}"

            # --- MOTD ---
            interactive_menu \
                "Custom MOTD (Message of the Day) (↑/↓ select, Enter confirm)" \
                "Shows system info on SSH login" \
                "Yes - Enable|Show CPU, RAM, disk usage on login" \
                "No - Disable|Keep default MOTD"
            [[ $MENU_SELECTED -eq 0 ]] && INSTALL_MOTD="yes" || INSTALL_MOTD="no"
            print_success "Custom MOTD: ${INSTALL_MOTD}"

            # --- PCI Passthrough ---
            interactive_menu \
                "PCI Passthrough Preparation (↑/↓ select, Enter confirm)" \
                "Enable IOMMU for GPU/NIC passthrough to VMs" \
                "No - Skip|Enable manually if needed later" \
                "Yes - Enable|Configure GRUB for IOMMU support"
            [[ $MENU_SELECTED -eq 1 ]] && ENABLE_PCI_PASSTHROUGH="yes" || ENABLE_PCI_PASSTHROUGH="no"
            print_success "PCI Passthrough: ${ENABLE_PCI_PASSTHROUGH}"

            # --- Journald Optimization ---
            interactive_menu \
                "Journald Log Optimization (↑/↓ select, Enter confirm)" \
                "Limit system logs to prevent disk fill" \
                "Yes - Enable|Limit logs to 1GB max" \
                "No - Disable|Keep default journald settings"
            [[ $MENU_SELECTED -eq 0 ]] && OPTIMIZE_JOURNALD="yes" || OPTIMIZE_JOURNALD="no"
            print_success "Journald optimization: ${OPTIMIZE_JOURNALD}"
        else
            print_success "Using default advanced options"
        fi
    fi
}

# =============================================================================
# Main input collection function
# =============================================================================

get_system_inputs() {
    detect_network_interface

    if [[ "$NON_INTERACTIVE" == true ]]; then
        print_success "Network interface: ${INTERFACE_NAME}"
        get_inputs_non_interactive
    else
        get_inputs_interactive
    fi

    collect_network_info

    # Calculate derived values
    FQDN="${PVE_HOSTNAME}.${DOMAIN_SUFFIX}"

    # Calculate private network values
    if [[ "$BRIDGE_MODE" == "internal" || "$BRIDGE_MODE" == "both" ]]; then
        PRIVATE_CIDR=$(echo "$PRIVATE_SUBNET" | cut -d'/' -f1 | rev | cut -d'.' -f2- | rev)
        PRIVATE_IP="${PRIVATE_CIDR}.1"
        SUBNET_MASK=$(echo "$PRIVATE_SUBNET" | cut -d'/' -f2)
        PRIVATE_IP_CIDR="${PRIVATE_IP}/${SUBNET_MASK}"
    fi

    # Save config if requested
    if [[ -n "$SAVE_CONFIG" ]]; then
        save_config "$SAVE_CONFIG"
    fi
}

# --- 08-packages.sh ---
# =============================================================================
# Package preparation and ISO download
# =============================================================================

prepare_packages() {
    echo "deb http://download.proxmox.com/debian/pve bookworm pve-no-subscription" > /etc/apt/sources.list.d/pve.list

    # Download Proxmox GPG key
    curl -fsSL -o /etc/apt/trusted.gpg.d/proxmox-release-bookworm.gpg https://enterprise.proxmox.com/debian/proxmox-release-bookworm.gpg &
    show_progress $! "Downloading Proxmox GPG key"
    wait $!
    if [[ $? -ne 0 ]]; then
        print_error "Failed to download Proxmox GPG key! Exiting."
        exit 1
    fi

    # Update package lists
    apt clean > /dev/null 2>&1
    apt update > /dev/null 2>&1 &
    show_progress $! "Updating package lists"
    wait $!
    if [[ $? -ne 0 ]]; then
        print_error "Failed to update package lists! Exiting."
        exit 1
    fi

    # Install packages
    apt install -yq proxmox-auto-install-assistant xorriso ovmf wget sshpass > /dev/null 2>&1 &
    show_progress $! "Installing packages"
    wait $!
    if [[ $? -ne 0 ]]; then
        print_error "Failed to install required packages! Exiting."
        exit 1
    fi
}

# Fetch latest Proxmox VE ISO
get_latest_proxmox_ve_iso() {
    local base_url="https://enterprise.proxmox.com/iso/"
    local latest_iso=$(curl -s "$base_url" | grep -oE 'proxmox-ve_[0-9]+\.[0-9]+-[0-9]+\.iso' | sort -V | tail -n1)

    if [[ -n "$latest_iso" ]]; then
        echo "${base_url}${latest_iso}"
    else
        echo "No Proxmox VE ISO found." >&2
        return 1
    fi
}

download_proxmox_iso() {
    if [[ -f "pve.iso" ]]; then
        print_success "Proxmox ISO already exists, skipping download"
        return 0
    fi

    PROXMOX_ISO_URL=$(get_latest_proxmox_ve_iso)
    if [[ -z "$PROXMOX_ISO_URL" ]]; then
        print_error "Failed to retrieve Proxmox ISO URL! Exiting."
        exit 1
    fi

    ISO_FILENAME=$(basename "$PROXMOX_ISO_URL")
    CHECKSUM_URL="https://enterprise.proxmox.com/iso/SHA256SUMS"

    # Download ISO with progress bar
    wget -q --show-progress -O pve.iso "$PROXMOX_ISO_URL" 2>&1 &
    show_progress $! "Downloading $ISO_FILENAME"
    wait $!
    if [[ $? -ne 0 ]]; then
        print_error "Failed to download Proxmox ISO! Exiting."
        exit 1
    fi

    if [[ ! -s "pve.iso" ]]; then
        print_error "Downloaded ISO file is empty or corrupted! Exiting."
        rm -f pve.iso
        exit 1
    fi

    # Verify ISO checksum with progress
    wget -q -O SHA256SUMS "$CHECKSUM_URL" 2>/dev/null &
    show_progress $! "Downloading checksum"
    wait $!

    if [[ -f "SHA256SUMS" ]]; then
        EXPECTED_CHECKSUM=$(grep "$ISO_FILENAME" SHA256SUMS | awk '{print $1}')
        if [[ -n "$EXPECTED_CHECKSUM" ]]; then
            sha256sum pve.iso > /tmp/iso_checksum.txt 2>/dev/null &
            show_progress $! "Verifying ISO checksum"
            wait $!
            ACTUAL_CHECKSUM=$(cat /tmp/iso_checksum.txt | awk '{print $1}')
            rm -f /tmp/iso_checksum.txt

            if [[ "$EXPECTED_CHECKSUM" == "$ACTUAL_CHECKSUM" ]]; then
                print_success "ISO checksum verified"
            else
                print_error "ISO checksum verification FAILED!"
                print_error "Expected: $EXPECTED_CHECKSUM"
                print_error "Actual:   $ACTUAL_CHECKSUM"
                rm -f pve.iso SHA256SUMS
                exit 1
            fi
        else
            print_warning "Could not find checksum for $ISO_FILENAME"
        fi
        rm -f SHA256SUMS
    else
        print_warning "Could not download checksum file"
    fi
}

make_answer_toml() {
    print_info "Making answer.toml..."

    # Build disk_list based on ZFS_RAID mode (using vda/vdb for QEMU virtio)
    case "$ZFS_RAID" in
        single)
            DISK_LIST='["/dev/vda"]'
            ;;
        raid0|raid1)
            DISK_LIST='["/dev/vda", "/dev/vdb"]'
            ;;
        *)
            # Default to raid1 for 2 drives
            DISK_LIST='["/dev/vda", "/dev/vdb"]'
            ;;
    esac

    cat <<EOF > answer.toml
[global]
    keyboard = "en-us"
    country = "us"
    fqdn = "$FQDN"
    mailto = "$EMAIL"
    timezone = "$TIMEZONE"
    root_password = "$NEW_ROOT_PASSWORD"
    reboot_on_error = false

[network]
    source = "from-dhcp"

[disk-setup]
    filesystem = "zfs"
    zfs.raid = "$ZFS_RAID"
    disk_list = $DISK_LIST

EOF
    print_success "answer.toml created (ZFS $ZFS_RAID mode)"
}

make_autoinstall_iso() {
    print_info "Making autoinstall.iso..."
    proxmox-auto-install-assistant prepare-iso pve.iso --fetch-from iso --answer-file answer.toml --output pve-autoinstall.iso
    print_success "pve-autoinstall.iso created"
}

# --- 09-qemu.sh ---
# =============================================================================
# QEMU installation and boot functions
# =============================================================================

is_uefi_mode() {
    [[ -d /sys/firmware/efi ]]
}

# Configure QEMU settings (shared between install and boot)
setup_qemu_config() {
    # UEFI configuration
    if is_uefi_mode; then
        UEFI_OPTS="-bios /usr/share/ovmf/OVMF.fd"
        print_info "UEFI mode detected"
    else
        UEFI_OPTS=""
        print_info "Legacy BIOS mode"
    fi

    # CPU and RAM configuration
    local available_cores=$(nproc)
    local available_ram_mb=$(free -m | awk '/^Mem:/{print $2}')

    QEMU_CORES=$((available_cores / 2))
    [[ $QEMU_CORES -lt 2 ]] && QEMU_CORES=2
    [[ $QEMU_CORES -gt $available_cores ]] && QEMU_CORES=$available_cores
    [[ $QEMU_CORES -gt 16 ]] && QEMU_CORES=16

    QEMU_RAM=8192
    [[ $available_ram_mb -lt 16384 ]] && QEMU_RAM=4096

    # Drive configuration
    DRIVE_ARGS="-drive file=$NVME_DRIVE_1,format=raw,media=disk,if=virtio"
    [[ -n "$NVME_DRIVE_2" ]] && DRIVE_ARGS="$DRIVE_ARGS -drive file=$NVME_DRIVE_2,format=raw,media=disk,if=virtio"
}

# Install Proxmox via QEMU
install_proxmox() {
    setup_qemu_config

    # Run QEMU in background and show progress
    qemu-system-x86_64 -enable-kvm $UEFI_OPTS \
        -cpu host -smp $QEMU_CORES -m $QEMU_RAM \
        -boot d -cdrom ./pve-autoinstall.iso \
        $DRIVE_ARGS -no-reboot -display none > /dev/null 2>&1 &

    show_progress $! "Installing Proxmox VE (${QEMU_CORES} vCPUs, ${QEMU_RAM}MB RAM)"
}

# Boot installed Proxmox with SSH port forwarding
boot_proxmox_with_port_forwarding() {
    print_success "Booting installed Proxmox with SSH port forwarding..."
    setup_qemu_config

    nohup qemu-system-x86_64 -enable-kvm $UEFI_OPTS \
        -cpu host -device e1000,netdev=net0 \
        -netdev user,id=net0,hostfwd=tcp::5555-:22 \
        -smp $QEMU_CORES -m $QEMU_RAM \
        $DRIVE_ARGS -display none \
        > qemu_output.log 2>&1 &

    QEMU_PID=$!

    # Wait for SSH with progress indicator (timeout 5 minutes)
    wait_with_progress "Waiting for Proxmox to boot" 300 "(echo >/dev/tcp/localhost/5555)" 3
}

# --- 10-configure-base.sh ---
# =============================================================================
# Base system configuration
# =============================================================================

make_template_files() {
    print_info "Modifying template files..."

    print_info "Downloading template files..."
    mkdir -p ./template_files

    download_file "./template_files/99-proxmox.conf" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/99-proxmox.conf"
    download_file "./template_files/hosts" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/hosts"
    download_file "./template_files/debian.sources" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/debian.sources"
    download_file "./template_files/proxmox.sources" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/proxmox.sources"

    # Security hardening templates
    download_file "./template_files/sshd_config" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/sshd_config"

    # Download interfaces template based on bridge mode
    local interfaces_template="interfaces.${BRIDGE_MODE:-internal}"
    download_file "./template_files/interfaces" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/${interfaces_template}"

    # Process hosts file
    print_info "Processing hosts file..."
    sed -i "s|{{MAIN_IPV4}}|$MAIN_IPV4|g" ./template_files/hosts
    sed -i "s|{{FQDN}}|$FQDN|g" ./template_files/hosts
    sed -i "s|{{HOSTNAME}}|$PVE_HOSTNAME|g" ./template_files/hosts
    sed -i "s|{{MAIN_IPV6}}|$MAIN_IPV6|g" ./template_files/hosts

    # Process interfaces file
    print_info "Processing interfaces file (mode: ${BRIDGE_MODE:-internal})..."
    sed -i "s|{{INTERFACE_NAME}}|$INTERFACE_NAME|g" ./template_files/interfaces
    sed -i "s|{{MAIN_IPV4}}|$MAIN_IPV4|g" ./template_files/interfaces
    sed -i "s|{{MAIN_IPV4_GW}}|$MAIN_IPV4_GW|g" ./template_files/interfaces
    sed -i "s|{{MAIN_IPV6}}|$MAIN_IPV6|g" ./template_files/interfaces
    sed -i "s|{{PRIVATE_IP_CIDR}}|$PRIVATE_IP_CIDR|g" ./template_files/interfaces
    sed -i "s|{{PRIVATE_SUBNET}}|$PRIVATE_SUBNET|g" ./template_files/interfaces
    sed -i "s|{{FIRST_IPV6_CIDR}}|$FIRST_IPV6_CIDR|g" ./template_files/interfaces

    print_success "Template files modified"
}

# Configure base system via SSH
configure_base_system() {
    print_info "Starting base system configuration via SSH..."
    make_template_files
    ssh-keygen -f "/root/.ssh/known_hosts" -R "[localhost]:5555" || true

    # Copy template files
    remote_copy "template_files/hosts" "/etc/hosts"
    remote_copy "template_files/interfaces" "/etc/network/interfaces"
    remote_copy "template_files/99-proxmox.conf" "/etc/sysctl.d/99-proxmox.conf"
    remote_copy "template_files/debian.sources" "/etc/apt/sources.list.d/debian.sources"
    remote_copy "template_files/proxmox.sources" "/etc/apt/sources.list.d/proxmox.sources"

    # Basic system configuration
    remote_exec "[ -f /etc/apt/sources.list ] && mv /etc/apt/sources.list /etc/apt/sources.list.bak"
    remote_exec "echo -e 'nameserver 1.1.1.1\nnameserver 1.0.0.1\nnameserver 8.8.8.8\nnameserver 8.8.4.4' > /etc/resolv.conf"
    remote_exec "echo '$PVE_HOSTNAME' > /etc/hostname"
    remote_exec "systemctl disable --now rpcbind rpcbind.socket"

    # Configure ZFS ARC memory limits
    print_info "Configuring ZFS ARC memory limits..."
    remote_exec_script << 'ZFSEOF'
        # Get total RAM in bytes
        TOTAL_RAM_KB=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        TOTAL_RAM_GB=$((TOTAL_RAM_KB / 1024 / 1024))

        # Calculate ARC limits (min: 1GB or 10% of RAM, max: 50% of RAM)
        if [ $TOTAL_RAM_GB -ge 128 ]; then
            ARC_MIN=$((16 * 1024 * 1024 * 1024))  # 16GB min for 128GB+ systems
            ARC_MAX=$((64 * 1024 * 1024 * 1024))  # 64GB max
        elif [ $TOTAL_RAM_GB -ge 64 ]; then
            ARC_MIN=$((8 * 1024 * 1024 * 1024))   # 8GB min
            ARC_MAX=$((32 * 1024 * 1024 * 1024))  # 32GB max
        elif [ $TOTAL_RAM_GB -ge 32 ]; then
            ARC_MIN=$((4 * 1024 * 1024 * 1024))   # 4GB min
            ARC_MAX=$((16 * 1024 * 1024 * 1024))  # 16GB max
        else
            ARC_MIN=$((1 * 1024 * 1024 * 1024))   # 1GB min
            ARC_MAX=$((TOTAL_RAM_KB * 1024 / 2))  # 50% of RAM max
        fi

        # Create ZFS configuration
        mkdir -p /etc/modprobe.d
        echo "options zfs zfs_arc_min=$ARC_MIN" > /etc/modprobe.d/zfs.conf
        echo "options zfs zfs_arc_max=$ARC_MAX" >> /etc/modprobe.d/zfs.conf

        echo "ZFS ARC configured: min=$(($ARC_MIN / 1024 / 1024 / 1024))GB, max=$(($ARC_MAX / 1024 / 1024 / 1024))GB"
ZFSEOF

    # Disable enterprise repositories
    print_info "Disabling enterprise repositories..."
    remote_exec_script << 'REPOEOF'
        # Disable ALL enterprise repositories (PVE, Ceph, Ceph-Squid, etc.)
        for repo_file in /etc/apt/sources.list.d/*.list /etc/apt/sources.list.d/*.sources; do
            [ -f "$repo_file" ] || continue
            if grep -q "enterprise.proxmox.com" "$repo_file" 2>/dev/null; then
                mv "$repo_file" "${repo_file}.disabled"
                echo "Disabled $(basename "$repo_file")"
            fi
        done

        # Also check and disable any enterprise sources in main sources.list
        if [ -f /etc/apt/sources.list ] && grep -q "enterprise.proxmox.com" /etc/apt/sources.list 2>/dev/null; then
            sed -i 's|^deb.*enterprise.proxmox.com|# &|g' /etc/apt/sources.list
            echo "Commented out enterprise repos in sources.list"
        fi
REPOEOF

    # Update all system packages
    remote_exec_with_progress "Updating system packages" '
        export DEBIAN_FRONTEND=noninteractive
        apt-get update -qq
        apt-get dist-upgrade -yqq
        apt-get autoremove -yqq
        apt-get clean
        pveupgrade 2>/dev/null || true
        pveam update 2>/dev/null || true
    '

    # Install monitoring and system utilities
    remote_exec_with_progress "Installing monitoring utilities" '
        export DEBIAN_FRONTEND=noninteractive
        apt-get install -yqq btop iotop ncdu tmux pigz smartmontools jq bat 2>/dev/null || {
            for pkg in btop iotop ncdu tmux pigz smartmontools jq bat; do
                apt-get install -yqq "$pkg" 2>/dev/null || true
            done
        }
        apt-get install -yqq libguestfs-tools 2>/dev/null || true
    '

    # Install and configure zsh as default shell
    print_info "Installing and configuring zsh..."
    remote_exec_script << 'ZSHEOF'
        export DEBIAN_FRONTEND=noninteractive
        apt-get install -yqq zsh zsh-autosuggestions zsh-syntax-highlighting

        # Create minimal .zshrc for root
        cat > /root/.zshrc << 'ZSHRC'
# Proxmox ZSH Configuration

# History settings
HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_SPACE
setopt SHARE_HISTORY
setopt APPEND_HISTORY

# Key bindings
bindkey -e
bindkey '^[[A' history-search-backward
bindkey '^[[B' history-search-forward
bindkey '^[[H' beginning-of-line
bindkey '^[[F' end-of-line
bindkey '^[[3~' delete-char

# Completion
autoload -Uz compinit && compinit
zstyle ':completion:*' menu select
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'

# Colors
autoload -Uz colors && colors

# Prompt with git branch support
autoload -Uz vcs_info
precmd() { vcs_info }
zstyle ':vcs_info:git:*' formats ' (%b)'
setopt PROMPT_SUBST
PROMPT='%F{cyan}%n@%m%f:%F{blue}%~%f%F{yellow}${vcs_info_msg_0_}%f %# '

# Aliases
alias ll='ls -lah --color=auto'
alias la='ls -A --color=auto'
alias l='ls -CF --color=auto'
alias grep='grep --color=auto'
alias df='df -h'
alias du='du -h'
alias free='free -h'
alias ..='cd ..'
alias ...='cd ../..'

# Proxmox aliases
alias qml='qm list'
alias pctl='pct list'
alias pvesh='pvesh'
alias zpl='zpool list'
alias zst='zpool status'

# Use bat instead of cat if available
command -v bat &>/dev/null && alias cat='bat --paging=never'

# Use btop instead of top if available
command -v btop &>/dev/null && alias top='btop'

# Load plugins if available
[ -f /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh ] && \
    source /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh
[ -f /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ] && \
    source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

# Auto-suggestions color (gray)
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=8'
ZSHRC

        # Set zsh as default shell for root
        chsh -s /bin/zsh root

        echo "ZSH installed and configured as default shell"
ZSHEOF
    print_success "ZSH configured as default shell"

    # Configure UTF-8 locales
    remote_exec_with_progress "Configuring UTF-8 locales" '
        export DEBIAN_FRONTEND=noninteractive
        apt-get install -yqq locales
        sed -i "s/# en_US.UTF-8/en_US.UTF-8/" /etc/locale.gen
        sed -i "s/# ru_RU.UTF-8/ru_RU.UTF-8/" /etc/locale.gen
        locale-gen
        update-locale LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8
    '

    # Configure CPU governor
    remote_exec_with_progress "Configuring CPU governor" '
        apt-get update -qq && apt-get install -yqq cpufrequtils 2>/dev/null || true
        echo "GOVERNOR=\"performance\"" > /etc/default/cpufrequtils
        if [ -d /sys/devices/system/cpu/cpu0/cpufreq ]; then
            for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
                [ -f "$cpu" ] && echo "performance" > "$cpu" 2>/dev/null || true
            done
        fi
    '

    # Remove Proxmox subscription notice
    print_info "Removing Proxmox subscription notice..."
    remote_exec_script << 'SUBEOF'
        if [ -f /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js ]; then
            sed -Ezi.bak "s/(Ext.Msg.show\(\{\s+title: gettext\('No valid sub)/void\(\{ \/\/\1/g" /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js
            systemctl restart pveproxy.service
            echo "Subscription notice removed"
        else
            echo "proxmoxlib.js not found, skipping"
        fi
SUBEOF

    print_success "Base system configuration complete"
}

# --- 11-configure-network.sh ---
# =============================================================================
# Network configuration
# =============================================================================

configure_network() {
    print_info "Starting network configuration..."

    # ==========================================================================
    # nf_conntrack configuration
    # ==========================================================================
    print_info "Configuring nf_conntrack..."
    remote_exec_script << 'CONNTRACKEOF'
        # Add nf_conntrack module to load at boot
        if ! grep -q "nf_conntrack" /etc/modules 2>/dev/null; then
            echo "nf_conntrack" >> /etc/modules
        fi

        # Configure connection tracking limits
        if ! grep -q "nf_conntrack_max" /etc/sysctl.d/99-proxmox.conf 2>/dev/null; then
            echo "net.netfilter.nf_conntrack_max=1048576" >> /etc/sysctl.d/99-proxmox.conf
            echo "net.netfilter.nf_conntrack_tcp_timeout_established=28800" >> /etc/sysctl.d/99-proxmox.conf
        fi

        echo "nf_conntrack configured"
CONNTRACKEOF

    # ==========================================================================
    # NTP Synchronization (always enabled)
    # ==========================================================================
    print_info "Configuring NTP time synchronization..."
    remote_exec_script << 'NTPEOF'
        # Enable and configure systemd-timesyncd
        apt-get install -yqq systemd-timesyncd 2>/dev/null || true

        # Configure NTP servers
        mkdir -p /etc/systemd/timesyncd.conf.d
        cat > /etc/systemd/timesyncd.conf.d/local.conf << 'CONF'
[Time]
NTP=0.pool.ntp.org 1.pool.ntp.org 2.pool.ntp.org 3.pool.ntp.org
FallbackNTP=ntp.ubuntu.com time.cloudflare.com
CONF

        # Enable and start timesyncd
        systemctl enable systemd-timesyncd
        systemctl restart systemd-timesyncd

        # Set hardware clock from system time
        hwclock --systohc 2>/dev/null || true

        echo "NTP synchronization configured"
NTPEOF
    print_success "NTP time synchronization configured"

    # ==========================================================================
    # Tailscale VPN (optional)
    # ==========================================================================
    if [[ "$INSTALL_TAILSCALE" == "yes" ]]; then
        remote_exec_with_progress "Installing Tailscale VPN" '
            curl -fsSL https://pkgs.tailscale.com/stable/debian/bookworm.noarmor.gpg | tee /usr/share/keyrings/tailscale-archive-keyring.gpg >/dev/null
            curl -fsSL https://pkgs.tailscale.com/stable/debian/bookworm.tailscale-keyring.list | tee /etc/apt/sources.list.d/tailscale.list
            apt-get update -qq
            apt-get install -yqq tailscale
            systemctl enable tailscaled
            systemctl start tailscaled
        '

        # Build tailscale up command with selected options
        TAILSCALE_UP_CMD="tailscale up"
        if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            TAILSCALE_UP_CMD="$TAILSCALE_UP_CMD --authkey='$TAILSCALE_AUTH_KEY'"
        fi
        if [[ "$TAILSCALE_SSH" == "yes" ]]; then
            TAILSCALE_UP_CMD="$TAILSCALE_UP_CMD --ssh"
        fi

        # If auth key is provided, authenticate Tailscale
        if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            print_info "Authenticating Tailscale with provided auth key..."
            remote_exec "$TAILSCALE_UP_CMD"

            # Get Tailscale IP and hostname for display
            TAILSCALE_IP=$(remote_exec "tailscale ip -4" 2>/dev/null || echo "pending")
            TAILSCALE_HOSTNAME=$(remote_exec "tailscale status --json | grep -o '\"DNSName\":\"[^\"]*\"' | head -1 | cut -d'\"' -f4 | sed 's/\\.$//' " 2>/dev/null || echo "")
            print_success "Tailscale authenticated. IP: ${TAILSCALE_IP}"

            # Configure Tailscale Serve for Proxmox Web UI
            if [[ "$TAILSCALE_WEBUI" == "yes" ]]; then
                print_info "Configuring Tailscale Serve for Proxmox Web UI..."
                remote_exec "tailscale serve --bg --https=443 https://127.0.0.1:8006"
                print_success "Proxmox Web UI available via Tailscale Serve"
            fi
        else
            TAILSCALE_IP="not authenticated"
            TAILSCALE_HOSTNAME=""
            print_warning "Tailscale installed but not authenticated."
            print_info "After reboot, run these commands to enable SSH and Web UI:"
            print_info "  tailscale up --ssh"
            print_info "  tailscale serve --bg --https=443 https://127.0.0.1:8006"
        fi
    fi

    # ==========================================================================
    # Basic Firewall (optional, default: no)
    # ==========================================================================
    if [[ "$INSTALL_FIREWALL" == "yes" ]]; then
        print_info "Configuring basic firewall rules..."
        remote_exec_script << 'FWEOF'
            export DEBIAN_FRONTEND=noninteractive
            apt-get install -yqq iptables-persistent netfilter-persistent

            # Flush existing rules
            iptables -F
            iptables -X
            iptables -t nat -F
            iptables -t nat -X

            # Default policies
            iptables -P INPUT DROP
            iptables -P FORWARD ACCEPT
            iptables -P OUTPUT ACCEPT

            # Allow loopback
            iptables -A INPUT -i lo -j ACCEPT

            # Allow established connections
            iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

            # Allow ICMP (ping)
            iptables -A INPUT -p icmp -j ACCEPT

            # Allow SSH (port 22)
            iptables -A INPUT -p tcp --dport 22 -j ACCEPT

            # Allow Proxmox Web UI (port 8006)
            iptables -A INPUT -p tcp --dport 8006 -j ACCEPT

            # Allow VNC console (ports 5900-5999)
            iptables -A INPUT -p tcp --dport 5900:5999 -j ACCEPT

            # Allow Spice console (port 3128)
            iptables -A INPUT -p tcp --dport 3128 -j ACCEPT

            # Allow Proxmox cluster communication (if needed)
            iptables -A INPUT -p tcp --dport 111 -j ACCEPT
            iptables -A INPUT -p udp --dport 111 -j ACCEPT
            iptables -A INPUT -p tcp --dport 85 -j ACCEPT

            # Allow internal bridge traffic
            iptables -A INPUT -i vmbr+ -j ACCEPT

            # Log dropped packets (optional, can be noisy)
            # iptables -A INPUT -j LOG --log-prefix "IPTables-Dropped: "

            # Save rules
            netfilter-persistent save

            # IPv6 rules (similar)
            ip6tables -F
            ip6tables -P INPUT DROP
            ip6tables -P FORWARD ACCEPT
            ip6tables -P OUTPUT ACCEPT
            ip6tables -A INPUT -i lo -j ACCEPT
            ip6tables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
            ip6tables -A INPUT -p ipv6-icmp -j ACCEPT
            ip6tables -A INPUT -p tcp --dport 22 -j ACCEPT
            ip6tables -A INPUT -p tcp --dport 8006 -j ACCEPT
            ip6tables -A INPUT -p tcp --dport 5900:5999 -j ACCEPT
            ip6tables -A INPUT -p tcp --dport 3128 -j ACCEPT
            ip6tables -A INPUT -i vmbr+ -j ACCEPT

            netfilter-persistent save

            echo "Firewall configured: SSH(22), PVE Web(8006), VNC, Spice allowed"
FWEOF
        print_success "Basic firewall configured"
    fi

    print_success "Network configuration complete"
}

# --- 12-configure-features.sh ---
# =============================================================================
# Optional features and finalization
# =============================================================================

configure_optional_features() {
    print_info "Configuring optional features..."

    # ==========================================================================
    # Hide Ceph from UI (optional, default: yes)
    # ==========================================================================
    if [[ "$HIDE_CEPH" == "yes" ]]; then
        print_info "Hiding Ceph from UI..."
        remote_exec_script << 'CEPHEOF'
            # Create custom CSS to hide Ceph-related UI elements
            CUSTOM_CSS="/usr/share/pve-manager/css/custom.css"
            cat > "$CUSTOM_CSS" << 'CSS'
/* Hide Ceph menu items - not needed for single server */
#pvelogoV { background-image: url(/pve2/images/logo.png) !important; }
.x-treelist-item-text:has-text("Ceph") { display: none !important; }
tr[data-qtip*="Ceph"] { display: none !important; }
CSS

            # Add custom CSS to index template if not already added
            INDEX_TMPL="/usr/share/pve-manager/index.html.tpl"
            if [ -f "$INDEX_TMPL" ] && ! grep -q "custom.css" "$INDEX_TMPL"; then
                sed -i '/<\/head>/i <link rel="stylesheet" type="text/css" href="/pve2/css/custom.css">' "$INDEX_TMPL"
                echo "Custom CSS added to hide Ceph"
            fi

            # Alternative: patch JavaScript to hide Ceph panel completely
            PVE_MANAGER_JS="/usr/share/pve-manager/js/pvemanagerlib.js"
            if [ -f "$PVE_MANAGER_JS" ]; then
                if ! grep -q "// Ceph hidden" "$PVE_MANAGER_JS"; then
                    sed -i "s/itemId: 'ceph'/itemId: 'ceph', hidden: true \/\/ Ceph hidden/g" "$PVE_MANAGER_JS" 2>/dev/null || true
                fi
            fi

            systemctl restart pveproxy.service
            echo "Ceph UI elements hidden"
CEPHEOF
    else
        print_info "Skipping Ceph UI hiding (disabled)"
    fi

    # ==========================================================================
    # Journald Optimization (optional, default: yes)
    # ==========================================================================
    if [[ "$OPTIMIZE_JOURNALD" == "yes" ]]; then
        print_info "Optimizing journald log settings..."
        remote_exec_script << 'JOURNALDEOF'
            mkdir -p /etc/systemd/journald.conf.d
            cat > /etc/systemd/journald.conf.d/size-limit.conf << 'CONF'
[Journal]
# Limit journal size to prevent disk fill
SystemMaxUse=1G
SystemKeepFree=2G
SystemMaxFileSize=100M
MaxRetentionSec=1month
MaxFileSec=1week
Compress=yes
CONF

            # Restart journald to apply changes
            systemctl restart systemd-journald

            # Clean up old logs
            journalctl --vacuum-size=500M 2>/dev/null || true

            echo "Journald optimized: max 1GB, 1 month retention"
JOURNALDEOF
        print_success "Journald optimization configured"
    fi

    # ==========================================================================
    # Unattended Upgrades (optional, default: yes)
    # ==========================================================================
    if [[ "$INSTALL_UNATTENDED_UPGRADES" == "yes" ]]; then
        remote_exec_with_progress "Configuring unattended security upgrades" '
            export DEBIAN_FRONTEND=noninteractive
            apt-get install -yqq unattended-upgrades apt-listchanges

            # Enable unattended upgrades
            cat > /etc/apt/apt.conf.d/20auto-upgrades << EOF
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
APT::Periodic::Download-Upgradeable-Packages "1";
APT::Periodic::AutocleanInterval "7";
EOF

            # Configure what to upgrade
            cat > /etc/apt/apt.conf.d/50unattended-upgrades << EOF
Unattended-Upgrade::Allowed-Origins {
    "\${distro_id}:\${distro_codename}";
    "\${distro_id}:\${distro_codename}-security";
    "\${distro_id}:\${distro_codename}-updates";
    "Proxmox:bookworm";
};
Unattended-Upgrade::Package-Blacklist {
    "proxmox-ve";
    "pve-kernel-*";
};
Unattended-Upgrade::DevRelease "false";
Unattended-Upgrade::AutoFixInterruptedDpkg "true";
Unattended-Upgrade::MinimalSteps "true";
Unattended-Upgrade::Remove-Unused-Dependencies "true";
Unattended-Upgrade::Automatic-Reboot "false";
EOF

            # Enable the service
            systemctl enable unattended-upgrades
            systemctl start unattended-upgrades

            echo "Unattended upgrades configured (security + updates, kernel excluded)"
        '
    fi

    # ==========================================================================
    # Custom MOTD (optional, default: yes)
    # ==========================================================================
    if [[ "$INSTALL_MOTD" == "yes" ]]; then
        print_info "Configuring custom MOTD..."
        remote_exec_script << 'MOTDEOF'
            # Disable default MOTD components
            chmod -x /etc/update-motd.d/* 2>/dev/null || true

            # Create custom MOTD script
            cat > /etc/update-motd.d/00-proxmox-info << 'SCRIPT'
#!/bin/bash
# Proxmox System Information MOTD

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Get system info
HOSTNAME=$(hostname)
UPTIME=$(uptime -p | sed 's/up //')
LOAD=$(cat /proc/loadavg | awk '{print $1", "$2", "$3}')
KERNEL=$(uname -r)

# CPU info
CPU_MODEL=$(grep "model name" /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)
CPU_CORES=$(nproc)
CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print 100 - $8}' | cut -d. -f1)

# Memory info
MEM_TOTAL=$(free -h | awk '/^Mem:/ {print $2}')
MEM_USED=$(free -h | awk '/^Mem:/ {print $3}')
MEM_PERCENT=$(free | awk '/^Mem:/ {printf "%.0f", $3/$2 * 100}')

# ZFS info
if command -v zpool &> /dev/null; then
    ZFS_POOL=$(zpool list -H -o name 2>/dev/null | head -1)
    if [ -n "$ZFS_POOL" ]; then
        ZFS_SIZE=$(zpool list -H -o size "$ZFS_POOL" 2>/dev/null)
        ZFS_USED=$(zpool list -H -o allocated "$ZFS_POOL" 2>/dev/null)
        ZFS_FREE=$(zpool list -H -o free "$ZFS_POOL" 2>/dev/null)
        ZFS_HEALTH=$(zpool list -H -o health "$ZFS_POOL" 2>/dev/null)
    fi
fi

# VM/CT counts
VMS=$(qm list 2>/dev/null | tail -n +2 | wc -l)
CTS=$(pct list 2>/dev/null | tail -n +2 | wc -l)
RUNNING_VMS=$(qm list 2>/dev/null | grep running | wc -l)
RUNNING_CTS=$(pct list 2>/dev/null | grep running | wc -l)

# Network info
IP_ADDR=$(hostname -I | awk '{print $1}')

echo ""
echo -e "${CYAN}${BOLD}╔══════════════════════════════════════════════════════════════╗${NC}"
echo -e "${CYAN}${BOLD}║${NC}              ${BLUE}${BOLD}Proxmox VE - ${HOSTNAME}${NC}              ${CYAN}${BOLD}║${NC}"
echo -e "${CYAN}${BOLD}╚══════════════════════════════════════════════════════════════╝${NC}"
echo ""
echo -e "${BOLD}System:${NC}"
echo -e "  Kernel:    ${KERNEL}"
echo -e "  Uptime:    ${UPTIME}"
echo -e "  Load:      ${LOAD}"
echo -e "  IP:        ${IP_ADDR}"
echo ""
echo -e "${BOLD}Resources:${NC}"
if [ "$CPU_USAGE" -gt 80 ]; then
    echo -e "  CPU:       ${RED}${CPU_USAGE}%${NC} (${CPU_CORES} cores)"
elif [ "$CPU_USAGE" -gt 50 ]; then
    echo -e "  CPU:       ${YELLOW}${CPU_USAGE}%${NC} (${CPU_CORES} cores)"
else
    echo -e "  CPU:       ${GREEN}${CPU_USAGE}%${NC} (${CPU_CORES} cores)"
fi

if [ "$MEM_PERCENT" -gt 80 ]; then
    echo -e "  Memory:    ${RED}${MEM_USED}/${MEM_TOTAL} (${MEM_PERCENT}%)${NC}"
elif [ "$MEM_PERCENT" -gt 50 ]; then
    echo -e "  Memory:    ${YELLOW}${MEM_USED}/${MEM_TOTAL} (${MEM_PERCENT}%)${NC}"
else
    echo -e "  Memory:    ${GREEN}${MEM_USED}/${MEM_TOTAL} (${MEM_PERCENT}%)${NC}"
fi

if [ -n "$ZFS_POOL" ]; then
    echo ""
    echo -e "${BOLD}ZFS Pool (${ZFS_POOL}):${NC}"
    if [ "$ZFS_HEALTH" = "ONLINE" ]; then
        echo -e "  Health:    ${GREEN}${ZFS_HEALTH}${NC}"
    else
        echo -e "  Health:    ${RED}${ZFS_HEALTH}${NC}"
    fi
    echo -e "  Used:      ${ZFS_USED} / ${ZFS_SIZE} (Free: ${ZFS_FREE})"
fi

echo ""
echo -e "${BOLD}Virtualization:${NC}"
echo -e "  VMs:       ${VMS} total, ${GREEN}${RUNNING_VMS} running${NC}"
echo -e "  CTs:       ${CTS} total, ${GREEN}${RUNNING_CTS} running${NC}"
echo ""
SCRIPT

            chmod +x /etc/update-motd.d/00-proxmox-info

            # Disable last login message
            sed -i 's/^#*PrintLastLog.*/PrintLastLog no/' /etc/ssh/sshd_config 2>/dev/null || true

            echo "Custom MOTD configured"
MOTDEOF
        print_success "Custom MOTD configured"
    fi

    # ==========================================================================
    # Fail2ban (optional, default: no)
    # ==========================================================================
    if [[ "$INSTALL_FAIL2BAN" == "yes" ]]; then
        remote_exec_with_progress "Installing and configuring Fail2ban" '
            export DEBIAN_FRONTEND=noninteractive
            apt-get install -yqq fail2ban

            # Create Proxmox-specific jail configuration
            cat > /etc/fail2ban/jail.d/proxmox.conf << EOF
[DEFAULT]
# Ban hosts for 1 hour
bantime = 3600
# Find failures within 10 minutes
findtime = 600
# Allow 5 retries before ban
maxretry = 5
# Ignore local networks
ignoreip = 127.0.0.1/8 ::1 10.0.0.0/8 192.168.0.0/16 172.16.0.0/12

[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 3600

[proxmox]
enabled = true
port = https,http,8006
filter = proxmox
logpath = /var/log/daemon.log
maxretry = 3
bantime = 3600
EOF

            # Create Proxmox filter
            cat > /etc/fail2ban/filter.d/proxmox.conf << EOF
[Definition]
failregex = pvedaemon\[.*authentication failure; rhost=<HOST> user=.* msg=.*
ignoreregex =
EOF

            # Enable and start fail2ban
            systemctl enable fail2ban
            systemctl restart fail2ban

            echo "Fail2ban configured with SSH and Proxmox jails"
        '
    fi

    # ==========================================================================
    # PCI Passthrough Preparation (optional, default: no)
    # ==========================================================================
    if [[ "$ENABLE_PCI_PASSTHROUGH" == "yes" ]]; then
        print_info "Configuring PCI passthrough (IOMMU)..."
        remote_exec_script << 'IOMMUEOF'
            # Detect CPU vendor
            if grep -q "GenuineIntel" /proc/cpuinfo; then
                IOMMU_PARAM="intel_iommu=on"
            elif grep -q "AuthenticAMD" /proc/cpuinfo; then
                IOMMU_PARAM="amd_iommu=on"
            else
                echo "Unknown CPU vendor, using intel_iommu"
                IOMMU_PARAM="intel_iommu=on"
            fi

            # Update GRUB configuration
            GRUB_FILE="/etc/default/grub"
            if [ -f "$GRUB_FILE" ]; then
                # Backup original
                cp "$GRUB_FILE" "${GRUB_FILE}.bak"

                # Add IOMMU parameters if not present
                if ! grep -q "iommu=on" "$GRUB_FILE"; then
                    sed -i "s/GRUB_CMDLINE_LINUX_DEFAULT=\"/GRUB_CMDLINE_LINUX_DEFAULT=\"${IOMMU_PARAM} iommu=pt /" "$GRUB_FILE"
                fi

                # Update GRUB
                update-grub
                echo "GRUB updated with IOMMU parameters"
            fi

            # Add VFIO modules
            cat > /etc/modules-load.d/vfio.conf << 'MODULES'
vfio
vfio_iommu_type1
vfio_pci
vfio_virqfd
MODULES

            # Blacklist GPU drivers for passthrough (commented by default)
            cat > /etc/modprobe.d/pci-passthrough.conf << 'BLACKLIST'
# Uncomment to blacklist drivers for GPU passthrough
# blacklist nouveau
# blacklist nvidia
# blacklist nvidiafb
# blacklist radeon
# blacklist amdgpu

# VFIO options
options vfio-pci ids=
BLACKLIST

            echo "PCI passthrough prepared. Reboot required to enable IOMMU."
            echo "To passthrough a device:"
            echo "1. Find device ID: lspci -nn"
            echo "2. Add ID to /etc/modprobe.d/pci-passthrough.conf"
            echo "3. Regenerate initramfs: update-initramfs -u -k all"
IOMMUEOF
        print_success "PCI passthrough prepared (reboot required)"
    fi

    # ==========================================================================
    # Let's Encrypt Certificate (optional, default: no)
    # ==========================================================================
    if [[ "$INSTALL_LETSENCRYPT" == "yes" && -n "$LETSENCRYPT_DOMAIN" ]]; then
        print_info "Configuring Let's Encrypt for ${LETSENCRYPT_DOMAIN}..."
        remote_exec_script << LEEOF
            export DEBIAN_FRONTEND=noninteractive

            # Install pve-acme for Proxmox ACME integration
            apt-get install -yqq pve-acme 2>/dev/null || true

            # Register ACME account if not exists
            if ! pvenode acme account list 2>/dev/null | grep -q "default"; then
                pvenode acme account register default --contact "${EMAIL}" --directory https://acme-v02.api.letsencrypt.org/directory
                echo "ACME account registered"
            fi

            # Configure domain for certificate
            pvenode config set --acme "domains=${LETSENCRYPT_DOMAIN}"

            # Order certificate
            if pvenode acme cert order 2>/dev/null; then
                echo "Let's Encrypt certificate obtained for ${LETSENCRYPT_DOMAIN}"

                # Setup auto-renewal cron
                if ! grep -q "pvenode acme cert renew" /etc/crontab 2>/dev/null; then
                    echo "0 3 * * * root pvenode acme cert renew --force 2>/dev/null" >> /etc/crontab
                    echo "Auto-renewal cron job added"
                fi
            else
                echo "Warning: Could not obtain certificate. Ensure DNS points to this server."
                echo "Run manually after reboot: pvenode acme cert order"
            fi
LEEOF
        print_success "Let's Encrypt configured for ${LETSENCRYPT_DOMAIN}"
    fi

    print_success "Optional features configuration complete"
}

# =============================================================================
# Finalize configuration (SSH hardening and shutdown)
# =============================================================================

finalize_configuration() {
    # Deploy SSH hardening LAST (after all other operations)
    print_info "Deploying SSH hardening..."

    # Deploy SSH public key FIRST (before disabling password auth!)
    remote_exec "mkdir -p /root/.ssh && chmod 700 /root/.ssh"
    remote_exec "echo '$SSH_PUBLIC_KEY' >> /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys"
    remote_copy "template_files/sshd_config" "/etc/ssh/sshd_config"

    print_success "Security hardening configured"

    # Power off the VM
    print_info "Powering off the VM..."
    remote_exec "poweroff" || true

    # Wait for QEMU to exit
    print_info "Waiting for QEMU process to exit..."
    wait $QEMU_PID || true
    print_success "QEMU process exited"
}

# =============================================================================
# Main configuration function (calls all stages)
# =============================================================================

configure_proxmox_via_ssh() {
    configure_base_system
    configure_network
    configure_optional_features
    finalize_configuration
}

# --- 99-main.sh ---
# =============================================================================
# Finish and reboot
# =============================================================================

# Calculate and display total installation time
show_total_time() {
    local end_time=$(date +%s)
    local total_seconds=$((end_time - INSTALL_START_TIME))
    local duration=$(format_duration $total_seconds)
    print_success "Total installation time: ${duration}"
}

# Function to reboot into the main OS
reboot_to_main_os() {
    echo -e "${CLR_GREEN}============================================${CLR_RESET}"
    echo -e "${CLR_GREEN}  Installation Complete!${CLR_RESET}"
    echo -e "${CLR_GREEN}============================================${CLR_RESET}"
    show_total_time
    echo ""
    echo -e "${CLR_YELLOW}Security Configuration Summary:${CLR_RESET}"
    echo "  ✓ SSH public key deployed"
    echo "  ✓ Password authentication DISABLED"
    echo "  ✓ CPU governor set to performance"
    echo "  ✓ Kernel parameters optimized for virtualization"
    echo "  ✓ Subscription notice removed"
    echo ""
    echo -e "${CLR_YELLOW}Post-Installation Optimizations:${CLR_RESET}"
    echo "  ✓ Monitoring utilities: btop, iotop, ncdu, tmux, pigz, smartmontools, jq, bat"
    echo "  ✓ VM image tools: libguestfs-tools"
    echo "  ✓ ZFS ARC memory limits configured"
    echo "  ✓ nf_conntrack optimized for high connection counts"
    if [[ "$INSTALL_TAILSCALE" == "yes" ]]; then
        echo "  ✓ Tailscale VPN installed (SSH + Web UI enabled)"
        if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            echo "  ✓ Tailscale authenticated (IP: ${TAILSCALE_IP:-pending})"
        else
            echo "  ⚠ Tailscale needs authentication after reboot:"
            echo "      tailscale up --ssh"
            echo "      tailscale serve --bg --https=443 https://127.0.0.1:8006"
        fi
    fi
    echo ""
    echo -e "${CLR_YELLOW}Access Information:${CLR_RESET}"
    echo "  Web UI:    https://${MAIN_IPV4_CIDR%/*}:8006"
    echo "  SSH:       ssh root@${MAIN_IPV4_CIDR%/*}"
    if [[ "$INSTALL_TAILSCALE" == "yes" && -n "$TAILSCALE_AUTH_KEY" && "$TAILSCALE_IP" != "pending" && "$TAILSCALE_IP" != "not authenticated" ]]; then
        echo "  Tailscale SSH: ssh root@${TAILSCALE_IP}"
        if [[ -n "$TAILSCALE_HOSTNAME" ]]; then
            echo "  Tailscale Web UI: https://${TAILSCALE_HOSTNAME}"
        else
            echo "  Tailscale Web UI: https://${TAILSCALE_IP}:8006"
        fi
    fi
    echo ""

    # Ask user to reboot the system
    read -e -p "Do you want to reboot the system? (y/n): " -i "y" REBOOT
    if [[ "$REBOOT" == "y" ]]; then
        print_info "Rebooting the system..."
        reboot
    else
        print_info "Exiting..."
        exit 0
    fi
}

# =============================================================================
# Main execution flow
# =============================================================================

# Collect system info and display status
collect_system_info
show_system_status
get_system_inputs
prepare_packages
download_proxmox_iso
make_answer_toml
make_autoinstall_iso
install_proxmox

# Boot and configure via SSH
boot_proxmox_with_port_forwarding || {
    print_error "Failed to boot Proxmox with port forwarding. Exiting."
    exit 1
}

# Configure Proxmox via SSH
configure_proxmox_via_ssh

# Reboot to the main OS
reboot_to_main_os
