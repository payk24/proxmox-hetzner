#!/usr/bin/env bash
# =============================================================================
# Proxmox VE Auto-Installer for Hetzner Dedicated Servers
# =============================================================================
# This file is auto-generated by build.sh - DO NOT EDIT DIRECTLY
# Edit the source files in scripts/src/ instead
#
# Source modules:
#   00-header.sh     - Colors and initial setup
#   01-helpers.sh    - Helper functions (SSH, download, progress)
#   02-validation.sh - Input validation functions
#   03-hardware.sh   - Hardware detection
#   04-input.sh      - User input collection
#   05-packages.sh   - Package installation and ISO download
#   06-qemu.sh       - QEMU installation functions
#   07-configure.sh  - Post-installation configuration
#   99-main.sh       - Main execution flow
# =============================================================================


# --- 00-header.sh ---
set -e
cd /root

# =============================================================================
# Colors and configuration
# =============================================================================
CLR_RED="\033[1;31m"
CLR_GREEN="\033[1;32m"
CLR_YELLOW="\033[1;33m"
CLR_BLUE="\033[1;34m"
CLR_CYAN="\033[1;36m"
CLR_RESET="\033[m"

# Version
VERSION="1.2.0"

# Log file
LOG_FILE="/root/pve-install-$(date +%Y%m%d-%H%M%S).log"

# Start time for total duration tracking
INSTALL_START_TIME=$(date +%s)

# Default values
NON_INTERACTIVE=false
CONFIG_FILE=""
SAVE_CONFIG=""

# =============================================================================
# Command line argument parsing
# =============================================================================
show_help() {
    cat << EOF
Proxmox VE Automated Installer for Hetzner v${VERSION}

Usage: $0 [OPTIONS]

Options:
  -h, --help              Show this help message
  -c, --config FILE       Load configuration from file
  -s, --save-config FILE  Save configuration to file after input
  -n, --non-interactive   Run without prompts (requires --config)
  -v, --version           Show version

Examples:
  $0                           # Interactive installation
  $0 -s proxmox.conf           # Interactive, save config for later
  $0 -c proxmox.conf           # Load config, prompt for missing values
  $0 -c proxmox.conf -n        # Fully automated installation

EOF
    exit 0
}

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        -v|--version)
            echo "Proxmox Installer v${VERSION}"
            exit 0
            ;;
        -c|--config)
            CONFIG_FILE="$2"
            shift 2
            ;;
        -s|--save-config)
            SAVE_CONFIG="$2"
            shift 2
            ;;
        -n|--non-interactive)
            NON_INTERACTIVE=true
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Validate non-interactive mode requires config
if [[ "$NON_INTERACTIVE" == true && -z "$CONFIG_FILE" ]]; then
    echo -e "${CLR_RED}Error: --non-interactive requires --config FILE${CLR_RESET}"
    exit 1
fi

# =============================================================================
# Config file functions
# =============================================================================
load_config() {
    local file="$1"
    if [[ -f "$file" ]]; then
        echo -e "${CLR_GREEN}✓ Loading configuration from: $file${CLR_RESET}"
        source "$file"
        return 0
    else
        echo -e "${CLR_RED}Config file not found: $file${CLR_RESET}"
        return 1
    fi
}

save_config() {
    local file="$1"
    cat > "$file" << EOF
# Proxmox Installer Configuration
# Generated: $(date)

# Network
INTERFACE_NAME="${INTERFACE_NAME}"

# System
PVE_HOSTNAME="${PVE_HOSTNAME}"
DOMAIN_SUFFIX="${DOMAIN_SUFFIX}"
TIMEZONE="${TIMEZONE}"
EMAIL="${EMAIL}"
BRIDGE_MODE="${BRIDGE_MODE}"
PRIVATE_SUBNET="${PRIVATE_SUBNET}"

# Password (consider using environment variable instead)
NEW_ROOT_PASSWORD="${NEW_ROOT_PASSWORD}"

# SSH
SSH_PUBLIC_KEY="${SSH_PUBLIC_KEY}"

# Tailscale
INSTALL_TAILSCALE="${INSTALL_TAILSCALE}"
TAILSCALE_AUTH_KEY="${TAILSCALE_AUTH_KEY}"
TAILSCALE_SSH="${TAILSCALE_SSH}"
TAILSCALE_WEBUI="${TAILSCALE_WEBUI}"

# ZFS RAID mode (single, raid0, raid1)
ZFS_RAID="${ZFS_RAID}"
EOF
    chmod 600 "$file"
    echo -e "${CLR_GREEN}✓ Configuration saved to: $file${CLR_RESET}"
}

# Load config if specified
if [[ -n "$CONFIG_FILE" ]]; then
    load_config "$CONFIG_FILE" || exit 1
fi

# =============================================================================
# Logging setup
# =============================================================================
exec > >(tee -a "$LOG_FILE") 2>&1

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

# =============================================================================
# Cursor management - ensure cursor is always visible on exit
# =============================================================================
cleanup_cursor() {
    tput cnorm 2>/dev/null || true
}
trap cleanup_cursor EXIT INT TERM

clear

# =============================================================================
# ASCII Banner
# =============================================================================
echo -e "${CLR_CYAN}"
cat << 'BANNER'
  ____
 |  _ \ _ __ _____  ___ __ ___   _____  __
 | |_) | '__/ _ \ \/ / '_ ` _ \ / _ \ \/ /
 |  __/| | | (_) >  <| | | | | | (_) >  <
 |_|   |_|  \___/_/\_\_| |_| |_|\___/_/\_\

    Hetzner Automated Installer
BANNER
echo -e "${CLR_RESET}"
echo -e "${CLR_YELLOW}Version: ${VERSION}${CLR_RESET}"
echo -e "${CLR_YELLOW}Log file: ${LOG_FILE}${CLR_RESET}"
if [[ -n "$CONFIG_FILE" ]]; then
    echo -e "${CLR_YELLOW}Config: ${CONFIG_FILE}${CLR_RESET}"
fi
if [[ "$NON_INTERACTIVE" == true ]]; then
    echo -e "${CLR_YELLOW}Mode: Non-interactive${CLR_RESET}"
fi
echo ""

# --- 01-display.sh ---
# =============================================================================
# Display utilities
# =============================================================================

# Display a boxed section with title using 'boxes'
# Usage: display_box "title" "content"
display_box() {
    local title="$1"
    local content="$2"
    local box_style="${3:-stone}"

    echo -e "${CLR_BLUE}"
    {
        echo "$title"
        echo ""
        echo "$content"
    } | boxes -d "$box_style" -p a1
    echo -e "${CLR_RESET}"
}

# Display system info table using boxes and column
# Takes associative array-like pairs: "label|value|status"
# status: ok=green, warn=yellow, error=red
display_info_table() {
    local title="$1"
    shift
    local items=("$@")

    local content=""
    for item in "${items[@]}"; do
        local label="${item%%|*}"
        local rest="${item#*|}"
        local value="${rest%%|*}"
        local status="${rest#*|}"

        case "$status" in
            ok)    content+="[OK]     $label: $value"$'\n' ;;
            warn)  content+="[WARN]   $label: $value"$'\n' ;;
            error) content+="[ERROR]  $label: $value"$'\n' ;;
            *)     content+="         $label: $value"$'\n' ;;
        esac
    done

    # Remove trailing newline and display
    content="${content%$'\n'}"

    echo ""
    {
        echo "=== $title ==="
        echo ""
        echo "$content"
    } | boxes -d stone -p a1
    echo ""
}

# Colorize the output of boxes (post-process)
colorize_status() {
    local green=$'\033[1;32m'
    local yellow=$'\033[1;33m'
    local red=$'\033[1;31m'
    local reset=$'\033[m'

    sed -e "s/\[OK\]/${green}[OK]${reset}/g" \
        -e "s/\[WARN\]/${yellow}[WARN]${reset}/g" \
        -e "s/\[ERROR\]/${red}[ERROR]${reset}/g"
}

# Print success message with checkmark
print_success() {
    echo -e "${CLR_GREEN}✓${CLR_RESET} $1"
}

# Print error message with cross
print_error() {
    echo -e "${CLR_RED}✗${CLR_RESET} $1"
}

# Print warning message
print_warning() {
    echo -e "${CLR_YELLOW}⚠${CLR_RESET} $1"
}

# Print info message
print_info() {
    echo -e "${CLR_CYAN}ℹ${CLR_RESET} $1"
}

# --- 02-utils.sh ---
# =============================================================================
# General utilities
# =============================================================================

# Download files with retry
download_file() {
    local output_file="$1"
    local url="$2"
    local max_retries=3
    local retry_count=0

    while [ $retry_count -lt $max_retries ]; do
        if wget -q -O "$output_file" "$url"; then
            if [ -s "$output_file" ]; then
                return 0
            else
                print_error "Downloaded file is empty: $output_file"
            fi
        else
            print_warning "Download failed (attempt $((retry_count + 1))/$max_retries): $url"
        fi
        retry_count=$((retry_count + 1))
        [ $retry_count -lt $max_retries ] && sleep 2
    done

    print_error "Failed to download $url after $max_retries attempts. Exiting."
    exit 1
}

# Function to read password with asterisks shown for each character
read_password() {
    local prompt="$1"
    local password=""
    local char=""

    # Output prompt to stderr so it's visible when stdout is captured
    echo -n "$prompt" >&2

    while IFS= read -r -s -n1 char; do
        if [[ -z "$char" ]]; then
            break
        fi
        if [[ "$char" == $'\x7f' || "$char" == $'\x08' ]]; then
            if [[ -n "$password" ]]; then
                password="${password%?}"
                echo -ne "\b \b" >&2
            fi
        else
            password+="$char"
            echo -n "*" >&2
        fi
    done

    # Newline to stderr for display
    echo "" >&2
    # Password to stdout for capture
    echo "$password"
}

# Prompt with validation loop
prompt_validated() {
    local prompt="$1"
    local default="$2"
    local validator="$3"
    local error_msg="$4"
    local result=""

    while true; do
        read -e -p "$prompt" -i "$default" result
        if $validator "$result"; then
            echo "$result"
            return 0
        fi
        print_error "$error_msg"
    done
}

# =============================================================================
# Progress indicators
# =============================================================================

# Spinner characters for progress display
SPINNER_CHARS='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'

# Progress indicator with spinner
show_progress() {
    local pid=$1
    local message="${2:-Processing}"
    local done_message="${3:-$message}"
    local i=0

    while kill -0 "$pid" 2>/dev/null; do
        printf "\r${CLR_YELLOW}${SPINNER_CHARS:i++%${#SPINNER_CHARS}:1} %s${CLR_RESET}" "$message"
        sleep 0.2
    done

    printf "\r\e[K${CLR_GREEN}✓ %s${CLR_RESET}\n" "$done_message"
}

# Wait for condition with progress
wait_with_progress() {
    local message="$1"
    local timeout="$2"
    local check_cmd="$3"
    local interval="${4:-5}"
    local done_message="${5:-$message}"
    local start_time=$(date +%s)
    local i=0

    while true; do
        local elapsed=$(($(date +%s) - start_time))

        if eval "$check_cmd" 2>/dev/null; then
            printf "\r\e[K${CLR_GREEN}✓ %s${CLR_RESET}\n" "$done_message"
            return 0
        fi

        if [ $elapsed -ge $timeout ]; then
            printf "\r\e[K${CLR_RED}✗ %s timed out${CLR_RESET}\n" "$message"
            return 1
        fi

        printf "\r${CLR_YELLOW}${SPINNER_CHARS:i++%${#SPINNER_CHARS}:1} %s${CLR_RESET}" "$message"
        sleep "$interval"
    done
}

# Format time duration
format_duration() {
    local seconds="$1"
    local hours=$((seconds / 3600))
    local minutes=$(((seconds % 3600) / 60))
    local secs=$((seconds % 60))

    if [[ $hours -gt 0 ]]; then
        echo "${hours}h ${minutes}m ${secs}s"
    else
        echo "${minutes}m ${secs}s"
    fi
}

# --- 03-ssh.sh ---
# =============================================================================
# SSH helper functions
# =============================================================================

SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR"
SSH_PORT="5555"

remote_exec() {
    sshpass -p "$NEW_ROOT_PASSWORD" ssh -p "$SSH_PORT" $SSH_OPTS root@localhost "$@"
}

remote_exec_script() {
    sshpass -p "$NEW_ROOT_PASSWORD" ssh -p "$SSH_PORT" $SSH_OPTS root@localhost 'bash -s'
}

# Execute remote script with progress indicator (hides output, shows spinner)
remote_exec_with_progress() {
    local message="$1"
    local script="$2"
    local done_message="${3:-$message}"

    echo "$script" | sshpass -p "$NEW_ROOT_PASSWORD" ssh -p "$SSH_PORT" $SSH_OPTS root@localhost 'bash -s' > /dev/null 2>&1 &
    local pid=$!
    show_progress $pid "$message" "$done_message"
    wait $pid
    return $?
}

remote_copy() {
    local src="$1"
    local dst="$2"
    sshpass -p "$NEW_ROOT_PASSWORD" scp -P "$SSH_PORT" $SSH_OPTS "$src" "root@localhost:$dst"
}

# =============================================================================
# SSH key utilities
# =============================================================================

# Parse SSH public key into components
# Sets: SSH_KEY_TYPE, SSH_KEY_DATA, SSH_KEY_COMMENT, SSH_KEY_SHORT
parse_ssh_key() {
    local key="$1"

    # Reset variables
    SSH_KEY_TYPE=""
    SSH_KEY_DATA=""
    SSH_KEY_COMMENT=""
    SSH_KEY_SHORT=""

    if [[ -z "$key" ]]; then
        return 1
    fi

    # Parse: type base64data [comment]
    SSH_KEY_TYPE=$(echo "$key" | awk '{print $1}')
    SSH_KEY_DATA=$(echo "$key" | awk '{print $2}')
    SSH_KEY_COMMENT=$(echo "$key" | awk '{$1=""; $2=""; print}' | sed 's/^ *//')

    # Create shortened version of key data (first 20 + last 10 chars)
    if [[ ${#SSH_KEY_DATA} -gt 35 ]]; then
        SSH_KEY_SHORT="${SSH_KEY_DATA:0:20}...${SSH_KEY_DATA: -10}"
    else
        SSH_KEY_SHORT="$SSH_KEY_DATA"
    fi

    return 0
}

# Validate SSH public key format
validate_ssh_key() {
    local key="$1"
    [[ "$key" =~ ^ssh-(rsa|ed25519|ecdsa)[[:space:]] ]]
}

# Get SSH key from rescue system authorized_keys
get_rescue_ssh_key() {
    if [[ -f /root/.ssh/authorized_keys ]]; then
        grep -E "^ssh-(rsa|ed25519|ecdsa)" /root/.ssh/authorized_keys 2>/dev/null | head -1
    fi
}

# --- 04-menu.sh ---
# =============================================================================
# Interactive menu selection
# =============================================================================
# Usage: interactive_menu "Title" "header_content" "label1|desc1" "label2|desc2" ...
# Sets: MENU_SELECTED (0-based index of selected option)
# Fixed width: 60 characters for consistent appearance

MENU_BOX_WIDTH=60

interactive_menu() {
    local title="$1"
    local header="$2"
    shift 2
    local items=("$@")

    local -a labels=()
    local -a descriptions=()

    # Parse items into labels and descriptions
    for item in "${items[@]}"; do
        labels+=("${item%%|*}")
        descriptions+=("${item#*|}")
    done

    local selected=0
    local key=""
    local box_lines=0
    local num_options=${#labels[@]}

    # Function to draw the menu box with fixed width
    _draw_menu() {
        local content=""

        # Add header content if provided
        if [[ -n "$header" ]]; then
            content+="$header"$'\n'
            content+=""$'\n'
        fi

        # Add options
        for i in "${!labels[@]}"; do
            if [ $i -eq $selected ]; then
                content+="[*] ${labels[$i]}"$'\n'
                content+="    └─ ${descriptions[$i]}"$'\n'
            else
                content+="[ ] ${labels[$i]}"$'\n'
                content+="    └─ ${descriptions[$i]}"$'\n'
            fi
        done

        # Remove trailing newline
        content="${content%$'\n'}"

        {
            echo "$title"
            echo "$content"
        } | boxes -d stone -p a1 -s $MENU_BOX_WIDTH
    }

    # Hide cursor
    tput civis

    # Calculate box height
    box_lines=$(_draw_menu | wc -l)

    # Draw initial menu
    _draw_menu | sed -e $'s/\\[\\*\\]/\033[1;32m[●]\033[m/g' \
                     -e $'s/\\[ \\]/\033[1;34m[○]\033[m/g'

    while true; do
        # Read a single keypress
        IFS= read -rsn1 key

        # Check for escape sequence (arrow keys)
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 0.1 key || true
            case "$key" in
                '[A') # Up arrow
                    ((selected--)) || true
                    [ $selected -lt 0 ] && selected=$((num_options - 1))
                    ;;
                '[B') # Down arrow
                    ((selected++)) || true
                    [ $selected -ge $num_options ] && selected=0
                    ;;
            esac
        elif [[ "$key" == "" ]]; then
            # Enter pressed - confirm selection
            break
        elif [[ "$key" =~ ^[1-9]$ ]] && [ "$key" -le "$num_options" ]; then
            # Number key pressed
            selected=$((key - 1))
            break
        fi

        # Move cursor up to redraw menu (fixes scroll issue)
        tput cuu $box_lines

        # Clear lines and redraw
        for ((i=0; i<box_lines; i++)); do
            printf "\033[2K\n"
        done
        tput cuu $box_lines

        # Draw the menu with colors
        _draw_menu | sed -e $'s/\\[\\*\\]/\033[1;32m[●]\033[m/g' \
                         -e $'s/\\[ \\]/\033[1;34m[○]\033[m/g'
    done

    # Show cursor again
    tput cnorm

    # Clear the menu box
    tput cuu $box_lines
    for ((i=0; i<box_lines; i++)); do
        printf "\033[2K\n"
    done
    tput cuu $box_lines

    # Set result
    MENU_SELECTED=$selected
}

# Display an input box and prompt for value
# Usage: input_box "title" "content" "prompt" "default" -> result in INPUT_VALUE
input_box() {
    local title="$1"
    local content="$2"
    local prompt="$3"
    local default="$4"

    local box_lines
    box_lines=$({
        echo "$title"
        echo "$content"
    } | boxes -d stone -p a1 -s $MENU_BOX_WIDTH | wc -l)

    {
        echo "$title"
        echo "$content"
    } | boxes -d stone -p a1 -s $MENU_BOX_WIDTH

    read -e -p "$prompt" -i "$default" INPUT_VALUE

    # Clear the input box
    tput cuu $((box_lines + 1))
    for ((i=0; i<box_lines+1; i++)); do
        printf "\033[2K\n"
    done
    tput cuu $((box_lines + 1))
}

# --- 05-validation.sh ---
# =============================================================================
# Input validation functions
# =============================================================================

validate_hostname() {
    local hostname="$1"
    # Hostname: alphanumeric and hyphens, 1-63 chars, cannot start/end with hyphen
    [[ "$hostname" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$ ]]
}

validate_fqdn() {
    local fqdn="$1"
    # FQDN: valid hostname labels separated by dots
    [[ "$fqdn" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$ ]]
}

validate_email() {
    local email="$1"
    # Basic email validation
    [[ "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
}

validate_password() {
    local password="$1"
    # Password must contain only ASCII printable characters (no Cyrillic or other non-ASCII)
    # Allowed: Latin letters, digits, and special characters (ASCII 32-126)
    # Using LC_ALL=C ensures only ASCII characters match [:print:]
    LC_ALL=C bash -c '[[ "$1" =~ ^[[:print:]]+$ ]]' _ "$password"
}

validate_subnet() {
    local subnet="$1"
    # Validate CIDR notation (e.g., 10.0.0.0/24)
    if [[ ! "$subnet" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/([0-9]|[12][0-9]|3[0-2])$ ]]; then
        return 1
    fi
    # Validate each octet is 0-255 using parameter expansion
    local ip="${subnet%/*}"
    local octet1 octet2 octet3 octet4 temp
    octet1="${ip%%.*}"
    temp="${ip#*.}"
    octet2="${temp%%.*}"
    temp="${temp#*.}"
    octet3="${temp%%.*}"
    octet4="${temp#*.}"

    [[ "$octet1" -le 255 && "$octet2" -le 255 && "$octet3" -le 255 && "$octet4" -le 255 ]]
}

validate_timezone() {
    local tz="$1"
    # Check if timezone file exists (preferred validation)
    if [[ -f "/usr/share/zoneinfo/$tz" ]]; then
        return 0
    fi
    # Fallback: In Rescue System, zoneinfo may not be available
    # Validate format (Region/City or Region/Subregion/City)
    if [[ "$tz" =~ ^[A-Za-z_]+/[A-Za-z_]+(/[A-Za-z_]+)?$ ]]; then
        print_warning "Cannot verify timezone in Rescue System, format looks valid."
        return 0
    fi
    return 1
}

# =============================================================================
# Input prompt helpers with validation
# =============================================================================

# Prompt for input with validation, showing success checkmark when valid
# Usage: prompt_with_validation "prompt" "default" "validator" "error_msg" "var_name"
prompt_with_validation() {
    local prompt="$1"
    local default="$2"
    local validator="$3"
    local error_msg="$4"
    local var_name="$5"

    local result
    while true; do
        read -e -p "$prompt" -i "$default" result
        if $validator "$result"; then
            printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${prompt}${result}\033[K\n"
            eval "$var_name=\"\$result\""
            return 0
        fi
        print_error "$error_msg"
    done
}

# Prompt for password with validation
# Usage: prompt_password "prompt" "var_name"
prompt_password() {
    local prompt="$1"
    local var_name="$2"
    local password

    password=$(read_password "$prompt")
    while [[ -z "$password" ]] || ! validate_password "$password"; do
        if [[ -z "$password" ]]; then
            print_error "Password cannot be empty!"
        else
            print_error "Password contains invalid characters (Cyrillic or non-ASCII)."
            print_error "Only Latin letters, digits, and special characters are allowed."
        fi
        password=$(read_password "$prompt")
    done
    printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${prompt}********\033[K\n"
    eval "$var_name=\"\$password\""
}

# --- 06-system-check.sh ---
# =============================================================================
# System checks and hardware detection
# =============================================================================

# Collect system info with progress indicator
collect_system_info() {
    local errors=0
    local checks=7
    local current=0
    local i=0

    # Progress update helper
    update_progress() {
        current=$((current + 1))
        local pct=$((current * 100 / checks))
        local filled=$((pct / 5))
        local empty=$((20 - filled))
        printf "\r${CLR_YELLOW}${SPINNER_CHARS:i++%${#SPINNER_CHARS}:1} Checking system... [${CLR_GREEN}"
        printf '█%.0s' $(seq 1 $filled 2>/dev/null) 2>/dev/null || true
        printf "${CLR_RESET}${CLR_BLUE}"
        printf '░%.0s' $(seq 1 $empty 2>/dev/null) 2>/dev/null || true
        printf "${CLR_RESET}${CLR_YELLOW}] %3d%%${CLR_RESET}" "$pct"
    }

    # Install display utilities (boxes for tables, column for alignment)
    update_progress
    local need_install=false
    command -v boxes &> /dev/null || need_install=true
    command -v column &> /dev/null || need_install=true
    if $need_install; then
        apt-get update -qq > /dev/null 2>&1
        apt-get install -qq -y boxes bsdmainutils > /dev/null 2>&1
    fi

    # Check if running as root
    update_progress
    if [[ $EUID -ne 0 ]]; then
        PREFLIGHT_ROOT="✗ Not root"
        PREFLIGHT_ROOT_STATUS="error"
        errors=$((errors + 1))
    else
        PREFLIGHT_ROOT="Running as root"
        PREFLIGHT_ROOT_STATUS="ok"
    fi
    sleep 0.1

    # Check internet connectivity
    update_progress
    if ping -c 1 -W 3 1.1.1.1 > /dev/null 2>&1; then
        PREFLIGHT_NET="Available"
        PREFLIGHT_NET_STATUS="ok"
    else
        PREFLIGHT_NET="No connection"
        PREFLIGHT_NET_STATUS="error"
        errors=$((errors + 1))
    fi

    # Check available disk space (need at least 5GB in /root)
    update_progress
    local free_space_mb=$(df -m /root | awk 'NR==2 {print $4}')
    if [[ $free_space_mb -ge 5000 ]]; then
        PREFLIGHT_DISK="${free_space_mb} MB"
        PREFLIGHT_DISK_STATUS="ok"
    else
        PREFLIGHT_DISK="${free_space_mb} MB (need 5GB+)"
        PREFLIGHT_DISK_STATUS="error"
        errors=$((errors + 1))
    fi
    sleep 0.1

    # Check RAM (need at least 4GB)
    update_progress
    local total_ram_mb=$(free -m | awk '/^Mem:/{print $2}')
    if [[ $total_ram_mb -ge 4000 ]]; then
        PREFLIGHT_RAM="${total_ram_mb} MB"
        PREFLIGHT_RAM_STATUS="ok"
    else
        PREFLIGHT_RAM="${total_ram_mb} MB (need 4GB+)"
        PREFLIGHT_RAM_STATUS="error"
        errors=$((errors + 1))
    fi
    sleep 0.1

    # Check CPU cores
    update_progress
    local cpu_cores=$(nproc)
    if [[ $cpu_cores -ge 2 ]]; then
        PREFLIGHT_CPU="${cpu_cores} cores"
        PREFLIGHT_CPU_STATUS="ok"
    else
        PREFLIGHT_CPU="${cpu_cores} core(s)"
        PREFLIGHT_CPU_STATUS="warn"
    fi
    sleep 0.1

    # Check if KVM is available
    update_progress
    if [[ -e /dev/kvm ]]; then
        PREFLIGHT_KVM="Available"
        PREFLIGHT_KVM_STATUS="ok"
    else
        PREFLIGHT_KVM="Not available"
        PREFLIGHT_KVM_STATUS="error"
        errors=$((errors + 1))
    fi
    sleep 0.1

    # Clear progress line
    printf "\r\033[K"

    PREFLIGHT_ERRORS=$errors
}

# Detect NVMe drives
detect_nvme_drives() {
    # Find all NVMe drives (excluding partitions)
    NVME_DRIVES=($(lsblk -d -n -o NAME,TYPE | grep nvme | grep disk | awk '{print "/dev/"$1}' | sort))
    NVME_COUNT=${#NVME_DRIVES[@]}

    # Collect drive info
    DRIVE_NAMES=()
    DRIVE_SIZES=()
    DRIVE_MODELS=()

    for drive in "${NVME_DRIVES[@]}"; do
        local name=$(basename "$drive")
        local size=$(lsblk -d -n -o SIZE "$drive" | xargs)
        local model=$(lsblk -d -n -o MODEL "$drive" 2>/dev/null | xargs || echo "NVMe")
        DRIVE_NAMES+=("$name")
        DRIVE_SIZES+=("$size")
        DRIVE_MODELS+=("$model")
    done

    # Set default RAID mode if not already set
    if [[ -z "$ZFS_RAID" ]]; then
        if [[ $NVME_COUNT -lt 2 ]]; then
            ZFS_RAID="single"
        else
            ZFS_RAID="raid1"
        fi
    fi

    # Set drive variables for QEMU
    NVME_DRIVE_1="${NVME_DRIVES[0]:-}"
    NVME_DRIVE_2="${NVME_DRIVES[1]:-}"
}

# Display system status
show_system_status() {
    detect_nvme_drives

    local nvme_error=0
    if [[ $NVME_COUNT -eq 0 ]]; then
        nvme_error=1
    fi

    # Build system info rows
    local sys_rows=""

    # Helper to add row
    add_row() {
        local status="$1"
        local label="$2"
        local value="$3"
        case "$status" in
            ok)    sys_rows+="[OK]|${label}|${value}"$'\n' ;;
            warn)  sys_rows+="[WARN]|${label}|${value}"$'\n' ;;
            error) sys_rows+="[ERROR]|${label}|${value}"$'\n' ;;
        esac
    }

    add_row "$PREFLIGHT_ROOT_STATUS" "Root Access" "$PREFLIGHT_ROOT"
    add_row "$PREFLIGHT_NET_STATUS" "Internet" "$PREFLIGHT_NET"
    add_row "$PREFLIGHT_DISK_STATUS" "Temp Space" "$PREFLIGHT_DISK"
    add_row "$PREFLIGHT_RAM_STATUS" "RAM" "$PREFLIGHT_RAM"
    add_row "$PREFLIGHT_CPU_STATUS" "CPU" "$PREFLIGHT_CPU"
    add_row "$PREFLIGHT_KVM_STATUS" "KVM" "$PREFLIGHT_KVM"

    # Remove trailing newline
    sys_rows="${sys_rows%$'\n'}"

    # Build storage rows
    local storage_rows=""
    if [[ $nvme_error -eq 1 ]]; then
        storage_rows="[ERROR]|No NVMe drives detected!|"
    else
        for i in "${!DRIVE_NAMES[@]}"; do
            storage_rows+="[OK]|${DRIVE_NAMES[$i]}|${DRIVE_SIZES[$i]}  ${DRIVE_MODELS[$i]:0:25}"
            if [[ $i -lt $((${#DRIVE_NAMES[@]} - 1)) ]]; then
                storage_rows+=$'\n'
            fi
        done
    fi

    # Display with boxes and colorize
    # Inner width = MENU_BOX_WIDTH - 4 (borders) - 2 (padding) = 54
    local inner_width=$((MENU_BOX_WIDTH - 6))
    {
        echo "SYSTEM INFORMATION"
        {
            echo "$sys_rows"
            echo "|--- Storage ---|"
            echo "$storage_rows"
        } | column -t -s '|' | while IFS= read -r line; do
            printf "%-${inner_width}s\n" "$line"
        done
    } | boxes -d stone -p a1 -s $MENU_BOX_WIDTH | colorize_status
    echo ""

    # Check for errors
    if [[ $PREFLIGHT_ERRORS -gt 0 ]]; then
        print_error "Pre-flight checks failed with $PREFLIGHT_ERRORS error(s). Exiting."
        exit 1
    fi

    if [[ $nvme_error -eq 1 ]]; then
        print_error "No NVMe drives detected! Exiting."
        exit 1
    fi

    print_success "All checks passed!"
    echo ""
}

# --- 07-input.sh ---
# =============================================================================
# User input functions
# =============================================================================

# Helper to prompt or use existing value
prompt_or_default() {
    local prompt="$1"
    local default="$2"
    local var_name="$3"
    local current_value="${!var_name}"

    if [[ "$NON_INTERACTIVE" == true ]]; then
        if [[ -n "$current_value" ]]; then
            echo "$current_value"
        else
            echo "$default"
        fi
    else
        local result
        read -e -p "$prompt" -i "${current_value:-$default}" result
        echo "$result"
    fi
}

# =============================================================================
# Network interface detection
# =============================================================================

detect_network_interface() {
    # Get default interface name (the one with default route)
    CURRENT_INTERFACE=$(ip route | grep default | awk '{print $5}' | head -n1)
    if [[ -z "$CURRENT_INTERFACE" ]]; then
        CURRENT_INTERFACE="eth0"
    fi

    # CRITICAL: Get the predictable interface name for bare metal
    # Rescue System often uses eth0, but Proxmox uses predictable naming
    PREDICTABLE_NAME=""

    # Try to get predictable name from udev
    if [[ -e "/sys/class/net/${CURRENT_INTERFACE}" ]]; then
        # Try ID_NET_NAME_PATH first (most reliable for PCIe devices)
        PREDICTABLE_NAME=$(udevadm info "/sys/class/net/${CURRENT_INTERFACE}" 2>/dev/null | grep "ID_NET_NAME_PATH=" | cut -d'=' -f2)

        # Fallback to ID_NET_NAME_ONBOARD (for onboard NICs)
        if [[ -z "$PREDICTABLE_NAME" ]]; then
            PREDICTABLE_NAME=$(udevadm info "/sys/class/net/${CURRENT_INTERFACE}" 2>/dev/null | grep "ID_NET_NAME_ONBOARD=" | cut -d'=' -f2)
        fi

        # Fallback to altname from ip link
        if [[ -z "$PREDICTABLE_NAME" ]]; then
            PREDICTABLE_NAME=$(ip -d link show "$CURRENT_INTERFACE" 2>/dev/null | grep "altname" | awk '{print $2}' | head -1)
        fi
    fi

    # Use predictable name if found
    if [[ -n "$PREDICTABLE_NAME" ]]; then
        DEFAULT_INTERFACE="$PREDICTABLE_NAME"
        print_success "Detected predictable interface name: ${PREDICTABLE_NAME} (current: ${CURRENT_INTERFACE})"
    else
        DEFAULT_INTERFACE="$CURRENT_INTERFACE"
        print_warning "Could not detect predictable name, using: ${CURRENT_INTERFACE}"
    fi

    # Get all available interfaces and their altnames for display
    AVAILABLE_ALTNAMES=$(ip -d link show | grep -v "lo:" | grep -E '(^[0-9]+:|altname)' | awk '/^[0-9]+:/ {interface=$2; gsub(/:/, "", interface); printf "%s", interface} /altname/ {printf ", %s", $2} END {print ""}' | sed 's/, $//')

    # Set INTERFACE_NAME to default if not already set
    if [[ -z "$INTERFACE_NAME" ]]; then
        INTERFACE_NAME="$DEFAULT_INTERFACE"
    fi
}

# Get network information from current interface
collect_network_info() {
    MAIN_IPV4_CIDR=$(ip address show "$CURRENT_INTERFACE" | grep global | grep "inet " | xargs | cut -d" " -f2)
    MAIN_IPV4=$(echo "$MAIN_IPV4_CIDR" | cut -d'/' -f1)
    MAIN_IPV4_GW=$(ip route | grep default | xargs | cut -d" " -f3)
    MAC_ADDRESS=$(ip link show "$CURRENT_INTERFACE" | awk '/ether/ {print $2}')
    IPV6_CIDR=$(ip address show "$CURRENT_INTERFACE" | grep global | grep "inet6 " | xargs | cut -d" " -f2)
    MAIN_IPV6=$(echo "$IPV6_CIDR" | cut -d'/' -f1)

    # Set a default value for FIRST_IPV6_CIDR
    if [[ -n "$IPV6_CIDR" ]]; then
        FIRST_IPV6_CIDR="$(echo "$IPV6_CIDR" | cut -d'/' -f1 | cut -d':' -f1-4):1::1/80"
    else
        FIRST_IPV6_CIDR=""
    fi
}

# =============================================================================
# Input collection - Non-interactive mode
# =============================================================================

get_inputs_non_interactive() {
    # Use defaults or config values
    PVE_HOSTNAME="${PVE_HOSTNAME:-pve}"
    DOMAIN_SUFFIX="${DOMAIN_SUFFIX:-local}"
    TIMEZONE="${TIMEZONE:-Europe/Kyiv}"
    EMAIL="${EMAIL:-admin@example.com}"
    BRIDGE_MODE="${BRIDGE_MODE:-internal}"
    PRIVATE_SUBNET="${PRIVATE_SUBNET:-10.0.0.0/24}"

    # Display configuration
    print_success "Network interface: ${INTERFACE_NAME}"
    print_success "Hostname: ${PVE_HOSTNAME}"
    print_success "Domain: ${DOMAIN_SUFFIX}"
    print_success "Timezone: ${TIMEZONE}"
    print_success "Email: ${EMAIL}"
    print_success "Bridge mode: ${BRIDGE_MODE}"

    if [[ "$BRIDGE_MODE" == "internal" || "$BRIDGE_MODE" == "both" ]]; then
        print_success "Private subnet: ${PRIVATE_SUBNET}"
    fi

    # ZFS RAID mode
    if [[ -z "$ZFS_RAID" ]]; then
        if [[ "${NVME_COUNT:-0}" -ge 2 ]]; then
            ZFS_RAID="raid1"
        else
            ZFS_RAID="single"
        fi
    fi
    print_success "ZFS mode: ${ZFS_RAID}"

    # Password required
    if [[ -z "$NEW_ROOT_PASSWORD" ]]; then
        print_error "NEW_ROOT_PASSWORD required in non-interactive mode"
        exit 1
    fi
    if ! validate_password "$NEW_ROOT_PASSWORD"; then
        print_error "Password contains invalid characters (Cyrillic or non-ASCII)."
        exit 1
    fi

    # SSH Public Key
    if [[ -z "$SSH_PUBLIC_KEY" ]]; then
        SSH_PUBLIC_KEY=$(get_rescue_ssh_key)
    fi
    if [[ -z "$SSH_PUBLIC_KEY" ]]; then
        print_error "SSH_PUBLIC_KEY required in non-interactive mode"
        exit 1
    fi
    parse_ssh_key "$SSH_PUBLIC_KEY"
    print_success "SSH key configured (${SSH_KEY_TYPE})"

    # Tailscale
    INSTALL_TAILSCALE="${INSTALL_TAILSCALE:-no}"
    if [[ "$INSTALL_TAILSCALE" == "yes" ]]; then
        TAILSCALE_SSH="${TAILSCALE_SSH:-yes}"
        TAILSCALE_WEBUI="${TAILSCALE_WEBUI:-yes}"
        if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            print_success "Tailscale will be installed (auto-connect)"
        else
            print_success "Tailscale will be installed (manual auth required)"
        fi
        print_success "Tailscale SSH: ${TAILSCALE_SSH}"
        print_success "Tailscale WebUI: ${TAILSCALE_WEBUI}"
    else
        print_success "Tailscale: skipped"
    fi
}

# =============================================================================
# Input collection - Interactive mode
# =============================================================================

get_inputs_interactive() {
    # =========================================================================
    # SECTION 1: Text inputs
    # =========================================================================

    # Network interface
    print_warning "Use the predictable name (enp*, eno*) for bare metal, not eth0"
    local iface_prompt="Interface name (options: ${AVAILABLE_ALTNAMES}): "
    read -e -p "$iface_prompt" -i "$INTERFACE_NAME" INTERFACE_NAME
    printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${iface_prompt}${INTERFACE_NAME}\033[K\n"

    # Hostname
    if [[ -n "$PVE_HOSTNAME" ]]; then
        print_success "Hostname: ${PVE_HOSTNAME} (from env)"
    else
        prompt_with_validation \
            "Enter your hostname (e.g., pve, proxmox): " \
            "pve" \
            "validate_hostname" \
            "Invalid hostname. Use only letters, numbers, and hyphens (1-63 chars)." \
            "PVE_HOSTNAME"
    fi

    # Domain
    if [[ -n "$DOMAIN_SUFFIX" ]]; then
        print_success "Domain: ${DOMAIN_SUFFIX} (from env)"
    else
        local domain_prompt="Enter domain suffix: "
        read -e -p "$domain_prompt" -i "local" DOMAIN_SUFFIX
        printf "\033[A\r${CLR_GREEN}✓${CLR_RESET} ${domain_prompt}${DOMAIN_SUFFIX}\033[K\n"
    fi

    # Email
    if [[ -n "$EMAIL" ]]; then
        print_success "Email: ${EMAIL} (from env)"
    else
        prompt_with_validation \
            "Enter your email address: " \
            "admin@example.com" \
            "validate_email" \
            "Invalid email address format." \
            "EMAIL"
    fi

    # Password
    if [[ -n "$NEW_ROOT_PASSWORD" ]]; then
        if ! validate_password "$NEW_ROOT_PASSWORD"; then
            print_error "Password contains invalid characters (Cyrillic or non-ASCII)."
            print_error "Only Latin letters, digits, and special characters are allowed."
            exit 1
        fi
        print_success "Password: ******** (from env)"
    else
        prompt_password "Enter your System New root password: " "NEW_ROOT_PASSWORD"
    fi

    # =========================================================================
    # SECTION 2: Interactive menus
    # =========================================================================

    # --- Timezone ---
    if [[ -n "$TIMEZONE" ]]; then
        print_success "Timezone: ${TIMEZONE} (from env)"
    else
        local tz_options=("Europe/Kyiv" "Europe/London" "Europe/Berlin" "America/New_York" "America/Los_Angeles" "Asia/Tokyo" "UTC" "custom")

        interactive_menu \
            "Timezone (↑/↓ select, Enter confirm)" \
            "" \
            "Europe/Kyiv|Ukraine" \
            "Europe/London|United Kingdom (GMT/BST)" \
            "Europe/Berlin|Germany, Central Europe (CET/CEST)" \
            "America/New_York|US Eastern Time (EST/EDT)" \
            "America/Los_Angeles|US Pacific Time (PST/PDT)" \
            "Asia/Tokyo|Japan Standard Time (JST)" \
            "UTC|Coordinated Universal Time" \
            "Custom|Enter timezone manually"

        if [[ $MENU_SELECTED -eq 7 ]]; then
            prompt_with_validation \
                "Enter your timezone: " \
                "Europe/Kyiv" \
                "validate_timezone" \
                "Invalid timezone. Use format like: Europe/London, America/New_York" \
                "TIMEZONE"
        else
            TIMEZONE="${tz_options[$MENU_SELECTED]}"
            print_success "Timezone: ${TIMEZONE}"
        fi
    fi

    # --- Bridge mode ---
    if [[ -n "$BRIDGE_MODE" ]]; then
        print_success "Bridge mode: ${BRIDGE_MODE} (from env)"
    else
        local bridge_options=("internal" "external" "both")
        local bridge_header="Configure network bridges for VMs and containers"$'\n'
        bridge_header+="vmbr0 = external (bridged to physical NIC)"$'\n'
        bridge_header+="vmbr1 = internal (NAT with private subnet)"

        interactive_menu \
            "Network Bridge Mode (↑/↓ select, Enter confirm)" \
            "$bridge_header" \
            "Internal only (NAT)|VMs use private IPs with NAT to internet" \
            "External only (Bridged)|VMs get IPs from your router/DHCP" \
            "Both bridges|Internal NAT + External bridged network"

        BRIDGE_MODE="${bridge_options[$MENU_SELECTED]}"
        case "$BRIDGE_MODE" in
            internal) print_success "Bridge mode: Internal NAT only (vmbr0)" ;;
            external) print_success "Bridge mode: External bridged only (vmbr0)" ;;
            both)     print_success "Bridge mode: Both (vmbr0=external, vmbr1=internal)" ;;
        esac
    fi

    # --- Private subnet ---
    if [[ "$BRIDGE_MODE" == "internal" || "$BRIDGE_MODE" == "both" ]]; then
        if [[ -n "$PRIVATE_SUBNET" ]]; then
            print_success "Private subnet: ${PRIVATE_SUBNET} (from env)"
        else
            local subnet_options=("10.0.0.0/24" "192.168.1.0/24" "172.16.0.0/24" "custom")

            interactive_menu \
                "Private Subnet (↑/↓ select, Enter confirm)" \
                "Internal network for VMs and containers" \
                "10.0.0.0/24|Class A private (recommended)" \
                "192.168.1.0/24|Class C private (common home network)" \
                "172.16.0.0/24|Class B private" \
                "Custom|Enter subnet manually"

            if [[ $MENU_SELECTED -eq 3 ]]; then
                prompt_with_validation \
                    "Enter your private subnet: " \
                    "10.0.0.0/24" \
                    "validate_subnet" \
                    "Invalid subnet. Use CIDR format like: 10.0.0.0/24" \
                    "PRIVATE_SUBNET"
            else
                PRIVATE_SUBNET="${subnet_options[$MENU_SELECTED]}"
                print_success "Private subnet: ${PRIVATE_SUBNET}"
            fi
        fi
    fi

    # --- ZFS RAID mode ---
    if [[ "${NVME_COUNT:-0}" -ge 2 ]]; then
        if [[ -n "$ZFS_RAID" ]]; then
            print_success "ZFS mode: ${ZFS_RAID} (from env)"
        else
            local zfs_options=("raid1" "raid0" "single")
            local zfs_labels=("RAID-1 (mirror) - Recommended" "RAID-0 (stripe) - No redundancy" "Single drive - No redundancy")

            interactive_menu \
                "ZFS Storage Mode (↑/↓ select, Enter confirm)" \
                "" \
                "${zfs_labels[0]}|Survives 1 disk failure" \
                "${zfs_labels[1]}|2x space & speed, data loss if any disk fails" \
                "${zfs_labels[2]}|Uses first drive only, ignores other drives"

            ZFS_RAID="${zfs_options[$MENU_SELECTED]}"
            print_success "ZFS mode: ${zfs_labels[$MENU_SELECTED]}"
        fi
    fi

    # --- SSH Public Key ---
    if [[ -n "$SSH_PUBLIC_KEY" ]]; then
        parse_ssh_key "$SSH_PUBLIC_KEY"
        print_success "SSH key: ${SSH_KEY_TYPE} (from env)"
    else
        local DETECTED_SSH_KEY=$(get_rescue_ssh_key)

        if [[ -n "$DETECTED_SSH_KEY" ]]; then
            parse_ssh_key "$DETECTED_SSH_KEY"

            local ssh_header="! Password authentication will be DISABLED"$'\n'
            ssh_header+="Detected key from Rescue System:"$'\n'
            ssh_header+="  Type:    ${SSH_KEY_TYPE}"$'\n'
            ssh_header+="  Key:     ${SSH_KEY_SHORT}"
            if [[ -n "$SSH_KEY_COMMENT" ]]; then
                ssh_header+=$'\n'"  Comment: ${SSH_KEY_COMMENT}"
            fi

            interactive_menu \
                "SSH Public Key (↑/↓ select, Enter confirm)" \
                "$ssh_header" \
                "Use detected key|Recommended - already configured in Hetzner" \
                "Enter different key|Paste your own SSH public key"

            if [[ $MENU_SELECTED -eq 0 ]]; then
                SSH_PUBLIC_KEY="$DETECTED_SSH_KEY"
                print_success "SSH key configured (${SSH_KEY_TYPE})"
            else
                SSH_PUBLIC_KEY=""
            fi
        fi

        # Manual entry if no key yet
        if [[ -z "$SSH_PUBLIC_KEY" ]]; then
            local ssh_content="! Password authentication will be DISABLED"$'\n'
            if [[ -z "$DETECTED_SSH_KEY" ]]; then
                ssh_content+=$'\n'"No SSH key detected in Rescue System."
            fi
            ssh_content+=$'\n'$'\n'"Paste your SSH public key below:"$'\n'
            ssh_content+="(Usually from ~/.ssh/id_ed25519.pub or ~/.ssh/id_rsa.pub)"

            input_box "SSH Public Key Configuration" "$ssh_content" "SSH Public Key: " ""

            while [[ -z "$INPUT_VALUE" ]] || ! validate_ssh_key "$INPUT_VALUE"; do
                if [[ -z "$INPUT_VALUE" ]]; then
                    print_error "SSH public key is required for secure access!"
                else
                    print_warning "SSH key format may be invalid. Continue anyway? (y/n): "
                    read -rsn1 confirm
                    echo ""
                    if [[ "$confirm" =~ ^[Yy]$ ]]; then
                        break
                    fi
                fi
                input_box "SSH Public Key Configuration" "$ssh_content" "SSH Public Key: " ""
            done

            SSH_PUBLIC_KEY="$INPUT_VALUE"
            parse_ssh_key "$SSH_PUBLIC_KEY"
            print_success "SSH key configured (${SSH_KEY_TYPE})"
        fi
    fi

    # --- Tailscale ---
    if [[ -n "$INSTALL_TAILSCALE" ]]; then
        if [[ "$INSTALL_TAILSCALE" == "yes" ]]; then
            TAILSCALE_SSH="${TAILSCALE_SSH:-yes}"
            TAILSCALE_WEBUI="${TAILSCALE_WEBUI:-yes}"
            if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
                print_success "Tailscale: yes (auto-connect, from env)"
            else
                print_success "Tailscale: yes (manual auth, from env)"
            fi
        else
            TAILSCALE_AUTH_KEY=""
            TAILSCALE_SSH="no"
            TAILSCALE_WEBUI="no"
            print_success "Tailscale: skipped (from env)"
        fi
    else
        local ts_header="Tailscale provides secure remote access to your server."$'\n'
        ts_header+="Auth key: https://login.tailscale.com/admin/settings/keys"

        interactive_menu \
            "Tailscale VPN - Optional (↑/↓ select, Enter confirm)" \
            "$ts_header" \
            "Install Tailscale|Recommended for secure remote access" \
            "Skip installation|Install Tailscale later if needed"

        if [[ $MENU_SELECTED -eq 0 ]]; then
            INSTALL_TAILSCALE="yes"
            TAILSCALE_SSH="yes"
            TAILSCALE_WEBUI="yes"

            if [[ -z "$TAILSCALE_AUTH_KEY" ]]; then
                local auth_content="Auth key enables automatic configuration."$'\n'
                auth_content+="Leave empty for manual auth after reboot."$'\n'
                auth_content+=$'\n'
                auth_content+="For unattended setup, use a reusable auth key"$'\n'
                auth_content+="with tags and expiry for better security."

                input_box "Tailscale Auth Key (optional)" "$auth_content" "Auth Key: " ""
                TAILSCALE_AUTH_KEY="$INPUT_VALUE"
            fi

            if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
                print_success "Tailscale will be installed (auto-connect)"
            else
                print_success "Tailscale will be installed (manual auth required)"
            fi
        else
            INSTALL_TAILSCALE="no"
            TAILSCALE_AUTH_KEY=""
            TAILSCALE_SSH="no"
            TAILSCALE_WEBUI="no"
            print_success "Tailscale installation skipped"
        fi
    fi
}

# =============================================================================
# Main input collection function
# =============================================================================

get_system_inputs() {
    detect_network_interface

    if [[ "$NON_INTERACTIVE" == true ]]; then
        print_success "Network interface: ${INTERFACE_NAME}"
        get_inputs_non_interactive
    else
        get_inputs_interactive
    fi

    collect_network_info

    # Calculate derived values
    FQDN="${PVE_HOSTNAME}.${DOMAIN_SUFFIX}"

    # Calculate private network values
    if [[ "$BRIDGE_MODE" == "internal" || "$BRIDGE_MODE" == "both" ]]; then
        PRIVATE_CIDR=$(echo "$PRIVATE_SUBNET" | cut -d'/' -f1 | rev | cut -d'.' -f2- | rev)
        PRIVATE_IP="${PRIVATE_CIDR}.1"
        SUBNET_MASK=$(echo "$PRIVATE_SUBNET" | cut -d'/' -f2)
        PRIVATE_IP_CIDR="${PRIVATE_IP}/${SUBNET_MASK}"
    fi

    # Save config if requested
    if [[ -n "$SAVE_CONFIG" ]]; then
        save_config "$SAVE_CONFIG"
    fi
}

# --- 08-packages.sh ---
# =============================================================================
# Package preparation and ISO download
# =============================================================================

prepare_packages() {
    echo "deb http://download.proxmox.com/debian/pve bookworm pve-no-subscription" > /etc/apt/sources.list.d/pve.list

    # Download Proxmox GPG key
    curl -fsSL -o /etc/apt/trusted.gpg.d/proxmox-release-bookworm.gpg https://enterprise.proxmox.com/debian/proxmox-release-bookworm.gpg &
    show_progress $! "Downloading Proxmox GPG key" "Proxmox GPG key downloaded"
    wait $!
    if [[ $? -ne 0 ]]; then
        print_error "Failed to download Proxmox GPG key! Exiting."
        exit 1
    fi

    # Update package lists
    apt clean > /dev/null 2>&1
    apt update > /dev/null 2>&1 &
    show_progress $! "Updating package lists" "Package lists updated"
    wait $!
    if [[ $? -ne 0 ]]; then
        print_error "Failed to update package lists! Exiting."
        exit 1
    fi

    # Install packages
    apt install -yq proxmox-auto-install-assistant xorriso ovmf wget sshpass > /dev/null 2>&1 &
    show_progress $! "Installing required packages" "Required packages installed"
    wait $!
    if [[ $? -ne 0 ]]; then
        print_error "Failed to install required packages! Exiting."
        exit 1
    fi
}

# Fetch latest Proxmox VE ISO
get_latest_proxmox_ve_iso() {
    local base_url="https://enterprise.proxmox.com/iso/"
    local latest_iso=$(curl -s "$base_url" | grep -oE 'proxmox-ve_[0-9]+\.[0-9]+-[0-9]+\.iso' | sort -V | tail -n1)

    if [[ -n "$latest_iso" ]]; then
        echo "${base_url}${latest_iso}"
    else
        echo "No Proxmox VE ISO found." >&2
        return 1
    fi
}

download_proxmox_iso() {
    if [[ -f "pve.iso" ]]; then
        print_success "Proxmox ISO already exists, skipping download"
        return 0
    fi

    PROXMOX_ISO_URL=$(get_latest_proxmox_ve_iso)
    if [[ -z "$PROXMOX_ISO_URL" ]]; then
        print_error "Failed to retrieve Proxmox ISO URL! Exiting."
        exit 1
    fi

    ISO_FILENAME=$(basename "$PROXMOX_ISO_URL")
    CHECKSUM_URL="https://enterprise.proxmox.com/iso/SHA256SUMS"

    # Download ISO with progress spinner (silent wget)
    wget -q -O pve.iso "$PROXMOX_ISO_URL" 2>/dev/null &
    show_progress $! "Downloading $ISO_FILENAME" "$ISO_FILENAME downloaded"
    wait $!
    if [[ $? -ne 0 ]]; then
        print_error "Failed to download Proxmox ISO! Exiting."
        exit 1
    fi

    if [[ ! -s "pve.iso" ]]; then
        print_error "Downloaded ISO file is empty or corrupted! Exiting."
        rm -f pve.iso
        exit 1
    fi

    # Download ISO checksum
    wget -q -O SHA256SUMS "$CHECKSUM_URL" 2>/dev/null

    if [[ -f "SHA256SUMS" ]]; then
        EXPECTED_CHECKSUM=$(grep "$ISO_FILENAME" SHA256SUMS | awk '{print $1}')
        if [[ -n "$EXPECTED_CHECKSUM" ]]; then
            sha256sum pve.iso > /tmp/iso_checksum.txt 2>/dev/null &
            show_progress $! "Verifying ISO checksum" "ISO checksum verified"
            wait $!
            ACTUAL_CHECKSUM=$(cat /tmp/iso_checksum.txt | awk '{print $1}')
            rm -f /tmp/iso_checksum.txt

            if [[ "$EXPECTED_CHECKSUM" != "$ACTUAL_CHECKSUM" ]]; then
                print_error "ISO checksum verification FAILED!"
                print_error "Expected: $EXPECTED_CHECKSUM"
                print_error "Actual:   $ACTUAL_CHECKSUM"
                rm -f pve.iso SHA256SUMS
                exit 1
            fi
        else
            print_warning "Could not find checksum for $ISO_FILENAME"
        fi
        rm -f SHA256SUMS
    else
        print_warning "Could not download checksum file"
    fi
}

make_answer_toml() {
    # Build disk_list based on ZFS_RAID mode (using vda/vdb for QEMU virtio)
    case "$ZFS_RAID" in
        single)
            DISK_LIST='["/dev/vda"]'
            ;;
        raid0|raid1)
            DISK_LIST='["/dev/vda", "/dev/vdb"]'
            ;;
        *)
            # Default to raid1 for 2 drives
            DISK_LIST='["/dev/vda", "/dev/vdb"]'
            ;;
    esac

    cat <<EOF > answer.toml
[global]
    keyboard = "en-us"
    country = "us"
    fqdn = "$FQDN"
    mailto = "$EMAIL"
    timezone = "$TIMEZONE"
    root_password = "$NEW_ROOT_PASSWORD"
    reboot_on_error = false

[network]
    source = "from-dhcp"

[disk-setup]
    filesystem = "zfs"
    zfs.raid = "$ZFS_RAID"
    disk_list = $DISK_LIST

EOF
}

make_autoinstall_iso() {
    proxmox-auto-install-assistant prepare-iso pve.iso --fetch-from iso --answer-file answer.toml --output pve-autoinstall.iso > /dev/null 2>&1 &
    show_progress $! "Creating autoinstall ISO" "Autoinstall ISO created"

    # Remove original ISO to save disk space (only autoinstall ISO is needed)
    rm -f pve.iso
}

# --- 09-qemu.sh ---
# =============================================================================
# QEMU installation and boot functions
# =============================================================================

is_uefi_mode() {
    [[ -d /sys/firmware/efi ]]
}

# Configure QEMU settings (shared between install and boot)
setup_qemu_config() {
    # UEFI configuration
    if is_uefi_mode; then
        UEFI_OPTS="-bios /usr/share/ovmf/OVMF.fd"
    else
        UEFI_OPTS=""
    fi

    # CPU and RAM configuration
    local available_cores=$(nproc)
    local available_ram_mb=$(free -m | awk '/^Mem:/{print $2}')

    QEMU_CORES=$((available_cores / 2))
    [[ $QEMU_CORES -lt 2 ]] && QEMU_CORES=2
    [[ $QEMU_CORES -gt $available_cores ]] && QEMU_CORES=$available_cores
    [[ $QEMU_CORES -gt 16 ]] && QEMU_CORES=16

    QEMU_RAM=8192
    [[ $available_ram_mb -lt 16384 ]] && QEMU_RAM=4096

    # Drive configuration
    DRIVE_ARGS="-drive file=$NVME_DRIVE_1,format=raw,media=disk,if=virtio"
    [[ -n "$NVME_DRIVE_2" ]] && DRIVE_ARGS="$DRIVE_ARGS -drive file=$NVME_DRIVE_2,format=raw,media=disk,if=virtio"
}

# Install Proxmox via QEMU
install_proxmox() {
    setup_qemu_config

    # Run QEMU in background and show progress
    qemu-system-x86_64 -enable-kvm $UEFI_OPTS \
        -cpu host -smp $QEMU_CORES -m $QEMU_RAM \
        -boot d -cdrom ./pve-autoinstall.iso \
        $DRIVE_ARGS -no-reboot -display none > /dev/null 2>&1 &

    show_progress $! "Installing Proxmox VE (${QEMU_CORES} vCPUs, ${QEMU_RAM}MB RAM)" "Proxmox VE installed"
}

# Boot installed Proxmox with SSH port forwarding
boot_proxmox_with_port_forwarding() {
    setup_qemu_config

    nohup qemu-system-x86_64 -enable-kvm $UEFI_OPTS \
        -cpu host -device e1000,netdev=net0 \
        -netdev user,id=net0,hostfwd=tcp::5555-:22 \
        -smp $QEMU_CORES -m $QEMU_RAM \
        $DRIVE_ARGS -display none \
        > qemu_output.log 2>&1 &

    QEMU_PID=$!

    # Wait for SSH with progress indicator (timeout 5 minutes)
    wait_with_progress "Booting installed Proxmox" 300 "(echo >/dev/tcp/localhost/5555)" 3 "Proxmox booted, SSH available"
}

# --- 10-configure.sh ---
# =============================================================================
# Post-installation configuration
# =============================================================================

make_template_files() {
    mkdir -p ./template_files
    local interfaces_template="interfaces.${BRIDGE_MODE:-internal}"

    # Download template files in background with progress
    (
        download_file "./template_files/99-proxmox.conf" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/99-proxmox.conf"
        download_file "./template_files/hosts" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/hosts"
        download_file "./template_files/debian.sources" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/debian.sources"
        download_file "./template_files/proxmox.sources" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/proxmox.sources"
        download_file "./template_files/sshd_config" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/sshd_config"
        download_file "./template_files/zshrc" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/zshrc"
        download_file "./template_files/chrony" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/chrony"
        download_file "./template_files/50unattended-upgrades" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/50unattended-upgrades"
        download_file "./template_files/20auto-upgrades" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/20auto-upgrades"
        download_file "./template_files/interfaces" "https://github.com/payk24/proxmox-hetzner/raw/refs/heads/main/template_files/${interfaces_template}"
    ) > /dev/null 2>&1 &
    show_progress $! "Downloading template files"

    # Modify template files in background with progress
    (
        sed -i "s|{{MAIN_IPV4}}|$MAIN_IPV4|g" ./template_files/hosts
        sed -i "s|{{FQDN}}|$FQDN|g" ./template_files/hosts
        sed -i "s|{{HOSTNAME}}|$PVE_HOSTNAME|g" ./template_files/hosts
        sed -i "s|{{MAIN_IPV6}}|$MAIN_IPV6|g" ./template_files/hosts
        sed -i "s|{{INTERFACE_NAME}}|$INTERFACE_NAME|g" ./template_files/interfaces
        sed -i "s|{{MAIN_IPV4}}|$MAIN_IPV4|g" ./template_files/interfaces
        sed -i "s|{{MAIN_IPV4_GW}}|$MAIN_IPV4_GW|g" ./template_files/interfaces
        sed -i "s|{{MAIN_IPV6}}|$MAIN_IPV6|g" ./template_files/interfaces
        sed -i "s|{{PRIVATE_IP_CIDR}}|$PRIVATE_IP_CIDR|g" ./template_files/interfaces
        sed -i "s|{{PRIVATE_SUBNET}}|$PRIVATE_SUBNET|g" ./template_files/interfaces
        sed -i "s|{{FIRST_IPV6_CIDR}}|$FIRST_IPV6_CIDR|g" ./template_files/interfaces
    ) &
    show_progress $! "Modifying template files"
}

# Configure the installed Proxmox via SSH
configure_proxmox_via_ssh() {
    make_template_files
    ssh-keygen -f "/root/.ssh/known_hosts" -R "[localhost]:5555" 2>/dev/null || true

    # Copy template files
    remote_copy "template_files/hosts" "/etc/hosts"
    remote_copy "template_files/interfaces" "/etc/network/interfaces"
    remote_copy "template_files/99-proxmox.conf" "/etc/sysctl.d/99-proxmox.conf"
    remote_copy "template_files/debian.sources" "/etc/apt/sources.list.d/debian.sources"
    remote_copy "template_files/proxmox.sources" "/etc/apt/sources.list.d/proxmox.sources"

    # Basic system configuration
    remote_exec "[ -f /etc/apt/sources.list ] && mv /etc/apt/sources.list /etc/apt/sources.list.bak"
    remote_exec "echo -e 'nameserver 1.1.1.1\nnameserver 1.0.0.1\nnameserver 8.8.8.8\nnameserver 8.8.4.4' > /etc/resolv.conf"
    remote_exec "echo '$PVE_HOSTNAME' > /etc/hostname"
    remote_exec "systemctl disable --now rpcbind rpcbind.socket 2>/dev/null"

    # Configure ZFS ARC memory limits
    remote_exec_with_progress "Configuring ZFS ARC memory limits" '
        TOTAL_RAM_KB=$(grep MemTotal /proc/meminfo | awk "{print \$2}")
        TOTAL_RAM_GB=$((TOTAL_RAM_KB / 1024 / 1024))

        if [ $TOTAL_RAM_GB -ge 128 ]; then
            ARC_MIN=$((16 * 1024 * 1024 * 1024))
            ARC_MAX=$((64 * 1024 * 1024 * 1024))
        elif [ $TOTAL_RAM_GB -ge 64 ]; then
            ARC_MIN=$((8 * 1024 * 1024 * 1024))
            ARC_MAX=$((32 * 1024 * 1024 * 1024))
        elif [ $TOTAL_RAM_GB -ge 32 ]; then
            ARC_MIN=$((4 * 1024 * 1024 * 1024))
            ARC_MAX=$((16 * 1024 * 1024 * 1024))
        else
            ARC_MIN=$((1 * 1024 * 1024 * 1024))
            ARC_MAX=$((TOTAL_RAM_KB * 1024 / 2))
        fi

        mkdir -p /etc/modprobe.d
        echo "options zfs zfs_arc_min=$ARC_MIN" > /etc/modprobe.d/zfs.conf
        echo "options zfs zfs_arc_max=$ARC_MAX" >> /etc/modprobe.d/zfs.conf
    ' "ZFS ARC memory limits configured"

    # Disable enterprise repositories
    remote_exec_with_progress "Disabling enterprise repositories" '
        for repo_file in /etc/apt/sources.list.d/*.list /etc/apt/sources.list.d/*.sources; do
            [ -f "$repo_file" ] || continue
            if grep -q "enterprise.proxmox.com" "$repo_file" 2>/dev/null; then
                mv "$repo_file" "${repo_file}.disabled"
            fi
        done

        if [ -f /etc/apt/sources.list ] && grep -q "enterprise.proxmox.com" /etc/apt/sources.list 2>/dev/null; then
            sed -i "s|^deb.*enterprise.proxmox.com|# &|g" /etc/apt/sources.list
        fi
    ' "Enterprise repositories disabled"

    # Update all system packages
    remote_exec_with_progress "Updating system packages" '
        export DEBIAN_FRONTEND=noninteractive
        apt-get update -qq
        apt-get dist-upgrade -yqq
        apt-get autoremove -yqq
        apt-get clean
        pveupgrade 2>/dev/null || true
        pveam update 2>/dev/null || true
    ' "System packages updated"

    # Install monitoring and system utilities
    remote_exec_with_progress "Installing system utilities" '
        export DEBIAN_FRONTEND=noninteractive
        apt-get install -yqq btop iotop ncdu tmux pigz smartmontools jq bat zsh zsh-autosuggestions zsh-syntax-highlighting 2>/dev/null || {
            for pkg in btop iotop ncdu tmux pigz smartmontools jq bat zsh zsh-autosuggestions zsh-syntax-highlighting; do
                apt-get install -yqq "$pkg" 2>/dev/null || true
            done
        }
        apt-get install -yqq libguestfs-tools 2>/dev/null || true
    ' "System utilities installed"

    # Configure UTF-8 locales (fix for btop and other apps)
    remote_exec_with_progress "Configuring UTF-8 locales" '
        export DEBIAN_FRONTEND=noninteractive
        apt-get install -yqq locales
        sed -i "s/# en_US.UTF-8/en_US.UTF-8/" /etc/locale.gen
        sed -i "s/# ru_RU.UTF-8/ru_RU.UTF-8/" /etc/locale.gen
        locale-gen
        update-locale LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8

        # Create locale profile for all shells (fixes btop display issues)
        cat > /etc/profile.d/locale.sh << "LOCALEEOF"
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export LANGUAGE=en_US.UTF-8
LOCALEEOF
        chmod +x /etc/profile.d/locale.sh

        # Also set in /etc/default/locale for systemd services
        cat > /etc/default/locale << "DEFLOCEOF"
LANG=en_US.UTF-8
LC_ALL=en_US.UTF-8
LANGUAGE=en_US.UTF-8
DEFLOCEOF

        # Set in /etc/environment for PAM (all sessions including non-login)
        cat > /etc/environment << "ENVEOF"
LANG=en_US.UTF-8
LC_ALL=en_US.UTF-8
LANGUAGE=en_US.UTF-8
ENVEOF
    ' "UTF-8 locales configured"

    # Configure ZSH as default shell for root
    (
        remote_copy "template_files/zshrc" "/root/.zshrc"
        remote_exec "chsh -s /bin/zsh root"
    ) > /dev/null 2>&1 &
    show_progress $! "Configuring ZSH" "ZSH configured"

    # Configure NTP time synchronization with chrony
    remote_exec_with_progress "Installing NTP (chrony)" '
        export DEBIAN_FRONTEND=noninteractive
        apt-get install -yqq chrony
        systemctl stop chrony
    ' "NTP (chrony) installed"
    remote_copy "template_files/chrony" "/etc/chrony/chrony.conf"
    remote_exec "systemctl enable chrony && systemctl start chrony" > /dev/null 2>&1

    # Configure Unattended Upgrades (security updates, kernel excluded)
    remote_exec_with_progress "Installing Unattended Upgrades" '
        export DEBIAN_FRONTEND=noninteractive
        apt-get install -yqq unattended-upgrades apt-listchanges
    ' "Unattended Upgrades installed"
    remote_copy "template_files/50unattended-upgrades" "/etc/apt/apt.conf.d/50unattended-upgrades"
    remote_copy "template_files/20auto-upgrades" "/etc/apt/apt.conf.d/20auto-upgrades"
    remote_exec "systemctl enable unattended-upgrades" > /dev/null 2>&1

    # Configure nf_conntrack
    remote_exec_with_progress "Configuring nf_conntrack" '
        if ! grep -q "nf_conntrack" /etc/modules 2>/dev/null; then
            echo "nf_conntrack" >> /etc/modules
        fi

        if ! grep -q "nf_conntrack_max" /etc/sysctl.d/99-proxmox.conf 2>/dev/null; then
            echo "net.netfilter.nf_conntrack_max=1048576" >> /etc/sysctl.d/99-proxmox.conf
            echo "net.netfilter.nf_conntrack_tcp_timeout_established=28800" >> /etc/sysctl.d/99-proxmox.conf
        fi
    ' "nf_conntrack configured"

    # Configure CPU governor
    remote_exec_with_progress "Configuring CPU governor" '
        apt-get update -qq && apt-get install -yqq cpufrequtils 2>/dev/null || true
        echo "GOVERNOR=\"performance\"" > /etc/default/cpufrequtils
        if [ -d /sys/devices/system/cpu/cpu0/cpufreq ]; then
            for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
                [ -f "$cpu" ] && echo "performance" > "$cpu" 2>/dev/null || true
            done
        fi
    ' "CPU governor configured"

    # Remove Proxmox subscription notice
    remote_exec_with_progress "Removing Proxmox subscription notice" '
        if [ -f /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js ]; then
            sed -Ezi.bak "s/(Ext.Msg.show\(\{\s+title: gettext\('"'"'No valid sub)/void\(\{ \/\/\1/g" /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js
            systemctl restart pveproxy.service
        fi
    ' "Subscription notice removed"

    # Install Tailscale if requested
    if [[ "$INSTALL_TAILSCALE" == "yes" ]]; then
        remote_exec_with_progress "Installing Tailscale VPN" '
            curl -fsSL https://pkgs.tailscale.com/stable/debian/bookworm.noarmor.gpg | tee /usr/share/keyrings/tailscale-archive-keyring.gpg >/dev/null
            curl -fsSL https://pkgs.tailscale.com/stable/debian/bookworm.tailscale-keyring.list | tee /etc/apt/sources.list.d/tailscale.list
            apt-get update -qq
            apt-get install -yqq tailscale
            systemctl enable tailscaled
            systemctl start tailscaled
        ' "Tailscale VPN installed"

        # Build tailscale up command with selected options
        TAILSCALE_UP_CMD="tailscale up"
        if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            TAILSCALE_UP_CMD="$TAILSCALE_UP_CMD --authkey='$TAILSCALE_AUTH_KEY'"
        fi
        if [[ "$TAILSCALE_SSH" == "yes" ]]; then
            TAILSCALE_UP_CMD="$TAILSCALE_UP_CMD --ssh"
        fi

        # If auth key is provided, authenticate Tailscale
        if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            (
                remote_exec "$TAILSCALE_UP_CMD"
                remote_exec "tailscale ip -4" > /tmp/tailscale_ip.txt 2>/dev/null
                remote_exec "tailscale status --json | grep -o '\"DNSName\":\"[^\"]*\"' | head -1 | cut -d'\"' -f4 | sed 's/\\.$//' " > /tmp/tailscale_hostname.txt 2>/dev/null
            ) > /dev/null 2>&1 &
            show_progress $! "Authenticating Tailscale"

            # Get Tailscale IP and hostname for display
            TAILSCALE_IP=$(cat /tmp/tailscale_ip.txt 2>/dev/null || echo "pending")
            TAILSCALE_HOSTNAME=$(cat /tmp/tailscale_hostname.txt 2>/dev/null || echo "")
            rm -f /tmp/tailscale_ip.txt /tmp/tailscale_hostname.txt
            # Overwrite completion line with IP
            printf "\033[1A\r${CLR_GREEN}✓ Tailscale authenticated. IP: ${TAILSCALE_IP}${CLR_RESET}                              \n"

            # Configure Tailscale Serve for Proxmox Web UI
            if [[ "$TAILSCALE_WEBUI" == "yes" ]]; then
                remote_exec "tailscale serve --bg --https=443 https://127.0.0.1:8006" > /dev/null 2>&1 &
                show_progress $! "Configuring Tailscale Serve" "Proxmox Web UI available via Tailscale Serve"
            fi

            # Disable OpenSSH when Tailscale SSH is enabled and authenticated
            if [[ "$TAILSCALE_SSH" == "yes" ]]; then
                remote_exec "systemctl disable --now ssh sshd 2>/dev/null || true" > /dev/null 2>&1 &
                show_progress $! "Disabling OpenSSH" "OpenSSH disabled (using Tailscale SSH only)"
            fi
        else
            TAILSCALE_IP="not authenticated"
            TAILSCALE_HOSTNAME=""
            print_warning "Tailscale installed but not authenticated."
            print_info "After reboot, run these commands to enable SSH and Web UI:"
            print_info "  tailscale up --ssh"
            print_info "  tailscale serve --bg --https=443 https://127.0.0.1:8006"
            print_info "Then disable OpenSSH: systemctl disable --now ssh"
        fi
    fi

    # Deploy SSH hardening (skip if Tailscale SSH is active)
    if [[ "$TAILSCALE_SSH" == "yes" && -n "$TAILSCALE_AUTH_KEY" ]]; then
        # Only deploy SSH key for emergency access, but keep SSH disabled
        (
            remote_exec "mkdir -p /root/.ssh && chmod 700 /root/.ssh"
            remote_exec "echo '$SSH_PUBLIC_KEY' >> /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys"
        ) > /dev/null 2>&1 &
        show_progress $! "Deploying SSH key" "SSH key deployed (for emergency access)"
    else
        (
            remote_exec "mkdir -p /root/.ssh && chmod 700 /root/.ssh"
            remote_exec "echo '$SSH_PUBLIC_KEY' >> /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys"
            remote_copy "template_files/sshd_config" "/etc/ssh/sshd_config"
        ) > /dev/null 2>&1 &
        show_progress $! "Deploying SSH hardening" "Security hardening configured"
    fi

    # Power off the VM
    remote_exec "poweroff" > /dev/null 2>&1 &
    show_progress $! "Powering off the VM"

    # Wait for QEMU to exit
    wait_with_progress "Waiting for QEMU process to exit" 120 "! kill -0 $QEMU_PID 2>/dev/null" 1 "QEMU process exited"
}

# --- 99-main.sh ---
# =============================================================================
# Finish and reboot
# =============================================================================

# Function to reboot into the main OS
reboot_to_main_os() {
    local inner_width=$((MENU_BOX_WIDTH - 6))

    # Build summary content
    local summary=""

    # Calculate duration
    local end_time=$(date +%s)
    local total_seconds=$((end_time - INSTALL_START_TIME))
    local duration=$(format_duration $total_seconds)

    summary+="[OK]|Installation time|${duration}"$'\n'
    summary+="|--- Security ---|"$'\n'
    summary+="[OK]|SSH public key|deployed"$'\n'
    summary+="[OK]|Password auth|DISABLED"$'\n'
    summary+="[OK]|CPU governor|performance"$'\n'
    summary+="[OK]|Kernel params|optimized"$'\n'
    summary+="[OK]|Subscription notice|removed"$'\n'
    summary+="|--- Optimizations ---|"$'\n'
    summary+="[OK]|Monitoring tools|btop, iotop, ncdu, tmux..."$'\n'
    summary+="[OK]|VM image tools|libguestfs-tools"$'\n'
    summary+="[OK]|ZFS ARC limits|configured"$'\n'
    summary+="[OK]|nf_conntrack|optimized"$'\n'
    summary+="[OK]|NTP sync|chrony (Hetzner)"$'\n'
    summary+="[OK]|Security updates|unattended"$'\n'

    # Tailscale status
    if [[ "$INSTALL_TAILSCALE" == "yes" ]]; then
        summary+="[OK]|Tailscale VPN|installed"$'\n'
        if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            summary+="[OK]|Tailscale IP|${TAILSCALE_IP:-pending}"$'\n'
            if [[ "$TAILSCALE_SSH" == "yes" ]]; then
                summary+="[OK]|OpenSSH|DISABLED (Tailscale only)"$'\n'
            fi
        else
            summary+="[WARN]|Tailscale|needs auth after reboot"$'\n'
        fi
    fi

    summary+="|--- Access ---|"$'\n'
    summary+="[OK]|Web UI|https://${MAIN_IPV4_CIDR%/*}:8006"$'\n'

    # Show SSH access based on configuration
    if [[ "$TAILSCALE_SSH" == "yes" && -n "$TAILSCALE_AUTH_KEY" ]]; then
        # OpenSSH disabled, only Tailscale SSH available
        if [[ "$TAILSCALE_IP" != "pending" && "$TAILSCALE_IP" != "not authenticated" ]]; then
            summary+="[OK]|SSH|root@${TAILSCALE_IP} (Tailscale)"
            if [[ -n "$TAILSCALE_HOSTNAME" ]]; then
                summary+=$'\n'"[OK]|Tailscale Web|https://${TAILSCALE_HOSTNAME}"
            fi
        else
            summary+="[WARN]|SSH|Tailscale pending"
        fi
    else
        # Regular SSH available
        summary+="[OK]|SSH|root@${MAIN_IPV4_CIDR%/*}"
        if [[ "$INSTALL_TAILSCALE" == "yes" && -n "$TAILSCALE_AUTH_KEY" && "$TAILSCALE_IP" != "pending" && "$TAILSCALE_IP" != "not authenticated" ]]; then
            summary+=$'\n'"[OK]|Tailscale SSH|root@${TAILSCALE_IP}"
            if [[ -n "$TAILSCALE_HOSTNAME" ]]; then
                summary+=$'\n'"[OK]|Tailscale Web|https://${TAILSCALE_HOSTNAME}"
            fi
        fi
    fi

    # Display ASCII art header (centered for MENU_BOX_WIDTH=60)
    echo ""
    echo '      ___                      _      _         _ _'
    echo '     / __|___ _ __  _ __  ___ | |__ _| |_ ___  | | |'
    echo '    | (__/ _ \  _ \|  _ \/ _ \| / _` |  _/ -_) |_|_|'
    echo '     \___\___/_|_|_|| .__/\___/|_\__,_|\__\___|(_|_)'
    echo '                    |_|'
    echo ""

    # Display with boxes
    {
        echo "INSTALLATION SUMMARY"
        echo "$summary" | column -t -s '|' | while IFS= read -r line; do
            printf "%-${inner_width}s\n" "$line"
        done
    } | boxes -d stone -p a1 -s $MENU_BOX_WIDTH | colorize_status
    echo ""

    # Show Tailscale auth instructions if needed
    if [[ "$INSTALL_TAILSCALE" == "yes" && -z "$TAILSCALE_AUTH_KEY" ]]; then
        print_warning "Tailscale needs authentication after reboot:"
        echo "    tailscale up --ssh"
        echo "    tailscale serve --bg --https=443 https://127.0.0.1:8006"
        echo ""
    fi

    # Ask user to reboot the system
    read -e -p "Do you want to reboot the system? (y/n): " -i "y" REBOOT
    if [[ "$REBOOT" == "y" ]]; then
        print_info "Rebooting the system..."
        reboot
    else
        print_info "Exiting..."
        exit 0
    fi
}

# =============================================================================
# Main execution flow
# =============================================================================

# Collect system info and display status
collect_system_info
show_system_status
get_system_inputs
prepare_packages
download_proxmox_iso
make_answer_toml
make_autoinstall_iso
install_proxmox

# Boot and configure via SSH
boot_proxmox_with_port_forwarding || {
    print_error "Failed to boot Proxmox with port forwarding. Exiting."
    exit 1
}

# Configure Proxmox via SSH
configure_proxmox_via_ssh

# Reboot to the main OS
reboot_to_main_os
